<?xml version="1.0" encoding="UTF-8"?>
<?oxygen RNGSchema="http://www.oasis-open.org/docbook/xml/5.0/rng/docbook.rng" type="xml"?>
<!-- # $Id$ -->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"
    version="5.0">
    <title>MediaWiki Manual</title>
    <!-- NEXUS INTRODUCTION SECTION -->
    <section>
        <title>NeXus Introduction</title>
        <para>In recent years, a number of scientists and computer programmers working in neutron
            and synchrotron facilities around the world came to the conclusion that a common data
            format would fulfil a valuable function in the scattering community. As instrumentation
            becomes more complex and data visualization become more challenging, individual
            scientists, or even institutions, have found it difficult to keep up with new
            developments. A common data format makes it easier, both to exchange experimental
            results and to exchange ideas about how to analyze them. It promotes greater cooperation
            in software development and stimulate the design of more sophisticated visualization
            tools. For additional background information see the 
            <!-- the @xml:id and link method does not work for the TKlink -->
            <!--<link linkend="BriefHistory">-->
                history of the NeXus format
            <!--</link>-->.</para>
        <para>This section is designed to give a brief introduction to NeXus, the data format that
            has been developed in response to these needs. It explains what a modern data format
            such as NeXus is and how to write simple programs to read and write NeXus files. </para>
        <section>
            <title>What is NeXus?</title>
            <para>The NeXus data format has four components: <variablelist>
                    <varlistentry>
                        <term>A set of subroutines</term>
                        <listitem>
                            <para>to make it easy to read and write NeXus files.</para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>A set of design principles</term>
                        <listitem>
                            <para>to help people understand what is in them.</para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>A set of instrument definitions</term>
                        <listitem>
                            <para>to allow the development of more portable analysis
                            software.</para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>A set of low-level file formats</term>
                        <listitem>
                            <para>to actually store NeXus files on physical media.</para>
                        </listitem>
                    </varlistentry>
                </variablelist></para>
            <section>
                <title>A Set of Subroutines</title>
                <para>In the past, a data format was defined by a document describing the precise
                    location of every item in the data file, either as row and column numbers in an
                    ASCII file, or as record and byte numbers in a binary file. In modern data
                    formats, such as NeXus, the user does not need to know where the data are
                    stored, just what they are called. It is the job of the subroutine library to
                    retrieve the data.</para>
                <para>For example, in NeXus, a program to read in the wavelength of an experiment
                    would contain lines similar to the following: <example>
                        <title>Simple example of reading data</title>
                        <programlisting>
NXopendata (fileID, "wavelength");
NXgetdata (fileID, lambda);
NXclosedata (fileID);
</programlisting>
                    </example> In this example, the program requests the value of the data that has
                    the label <code>wavelength</code>, storing the result in the variable lambda.
                        <code>fileID</code> is a file identifier that is provided by NeXus when the
                    file is opened. </para>
                <para>We shall provide a more complete example when we have discussed the contents
                    of the NeXus files.</para>
            </section>
            <section>
                <title>A Set of Design Principles</title>
                <para>NeXus data files contain two types of entity: data items and data groups. <variablelist>
                        <varlistentry>
                            <term>Data Items</term>
                            <listitem>
                                <para>These can be scalar values or multidimensional arrays of a
                                    variety of sizes (1-byte, 2-byte, 4-byte, 8-byte) and types
                                    (characters, integers, floats). Extra information required to
                                    describe a particular data item, such as the data units, can be
                                    stored as a data attribute. </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>Data Groups</term>
                            <listitem>
                                <para>These are like folders that can contain a number of data items
                                    and/or other groups.</para>
                            </listitem>
                        </varlistentry>
                    </variablelist></para>
                <para>In fact, a NeXus file can be viewed as a computer file system. Just as files
                    are stored in folders (or subdirectories) to make them easy to locate, so NeXus
                    data items are stored in groups. The group hierarchy is designed to make it easy
                    to navigate a NeXus file.</para>
                <section>
                    <title>Example of a NeXus File</title>
                    <para>The following diagram shows an example of a NeXus file represented as a
                        tree structure. <figure>
                            <title>Example of a NeXus files</title>
                            <mediaobject>
                                <imageobject>
                                    <imagedata fileref="img/Hierarchy.gif"/>
                                </imageobject>
                            </mediaobject>
                        </figure> Note that each data item is identified by a name, e.g., counts,
                        but each group is identified both by a name and, in parentheses, a class
                        identifier, e.g., monitor (NXmonitor). The class names, which all begin with
                        NX, define the sort of data items that the group should contain, in this
                        case, counts from a beamline monitor. The hierarchical design, with data
                        items nested in groups, makes it easy to identify information if you are
                        browsing through a file. </para>
                </section>
                <section>
                    <title>Important Classes</title>
                    <para>Here are some of the important classes found in nearly all NeXus files. A
                        complete list can be found in the [[Design|NeXus Design page]]TKlink. <variablelist>
                            <varlistentry>
                                <term>NXentry</term>
                                <listitem>
                                    <para>The top level of any NeXus file contains one or more
                                        groups with the class NXentry. These contain all the data
                                        that is required to describe an experimental run or scan.
                                        Each NXentry typically contains a number of groups
                                        describing sample information (class NXsample), instrument
                                        details (class NXinstrument), and monitor counts (class
                                        NXmonitor). </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term>NXdata</term>
                                <listitem>
                                    <para>Each NXentry group contains one or more groups with class
                                        NXdata. These groups contain the experimental results in a
                                        self-contained way, i.e., it should be possible to generate
                                        a sensible plot of the data from the information contained
                                        in each NXdata group. That means it should contain the axis
                                        labels and titles as well as the data.</para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term>NXsample</term>
                                <listitem>
                                    <para>A NXentry group will often contain a group with class
                                        NXsample. This group contains information pertaining to the
                                        sample, such as its chemical composition, mass, and
                                        environment variables (temperature, pressure, magnetic
                                        field, etc.).</para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term>NXinstrument</term>
                                <listitem>
                                    <para>There might also be a group with class NXinstrument. This
                                        is designed to encapsulate all the instrumental information
                                        that might be relevant to a measurement, such as flight
                                        paths, collimations, chopper frequencies, etc.</para>
                                </listitem>
                            </varlistentry>
                        </variablelist><figure>
                            <title>NXinstrument excerpt</title>
                            <mediaobject>
                                <imageobject>
                                    <imagedata fileref="img/NXinstrument.gif"/>
                                </imageobject>
                            </mediaobject>
                        </figure> Since an instrument can comprise several beamline components each
                        defined by several parameters, they are each specified by a separate group.
                        This hides the complexity from generic file browsers, but makes the
                        information available in an intuitively obvious way if it is required.
                    </para>
                </section>
                <section>
                    <title>Simple Example</title>
                    <para>NeXus data files do not need to be complicated. In fact, the following
                        diagram shows an extremely simple NeXus file that could be used to transfer
                        data between programs. <figure>
                            <title>Simple Example</title>
                            <mediaobject>
                                <imageobject>
                                    <imagedata fileref="img/Simple.gif"/>
                                </imageobject>
                            </mediaobject>
                        </figure> This illustrates the fact that the structure of NeXus files is
                        extremely flexible. It can accommodate very complex instrumental
                        information, if required, but it can also be used to store very simple data
                        sets. </para>
                </section>
            </section>
            <section>
                <title>A Set of Instrument Definitions</title>
                <para>If the design principles are followed, it will be easy for anyone browsing a
                    NeXus file to understand what it contains, without any prior information.
                    However, if you are writing visualization or analysis software, you will need to
                    know precisely what information is contained in advance. For that reason, NeXus
                    provides a way of defining the format for particular instrument types, e.g.,
                    time-of-flight small angle neutron scattering. This requires some agreement by
                    the relevant communities, but would allow the development of much more portable
                    software.</para>
                <para>These instrument definitions are being formalized as XML files, using a
                    specially devised syntax that specifies the names of data items, and whether
                    they are optional or required. The following is an example of such a file for
                    the simple NeXus file shown above. <example>
                        <title>A very simple NeXus file</title>
                        <programlisting><![CDATA[
<?xml version="1.0" ?> 
<!--
URL: http://www.neutron.anl.gov/nexus/xml/simple.xml
Editor: Ray Osborn <ROsborn@anl.gov>
$Id$

A very simple NeXus file

-->
<NXentry name="{Name of entry}">
   <NXdata name="{Name of data}">
     <time_of_flight units="microseconds" type="NX_FLOAT32[i]">{Time-of-flight}</time_of_flight>
     <data type="NX_INT32[i]" axes="time_of_flight"> {Counts} </data>
   </NXdata>
</NXentry>
]]></programlisting>
                    </example> If you want to define the format of a particular type of NeXus file
                    for your own use, e.g. as the standard output from a program, you are encouraged
                    to "publish" the format using this XML format. </para>
            </section>
            <section>
                <title>A Set of Low-Level File Formats</title>
                <para>To actually store NeXus files on physical media, different low-level file
                    formats are available, namely HDF4, HDF5, and XML. The NeXus library may be
                    configured to support all of them, or any nonempty subset. Applications that
                    create NeXus files need to decide (or let the user decide) in which low-level
                    format data shall be stored. Generic data analysis applications should be able
                    to read any low-level format.</para>
            </section>
        </section>
        <section>
            <title>How do I write a NeXus file?</title>
            <para>The NeXus Application Program Interface (API) provides a set of subroutines that
                make it easy to read and write NeXus files. These subroutines are available in C,
                Fortran 77, Fortran 90, Java, and IDL. Access from other languages, such as Python,
                is anticipated in the near future. It is also possible to read NeXus files in a
                number of data analysis tools, such as LAMP, ISAW, and Open GENIE.</para>
            <para>The API uses a very simple "state" model to navigate through a NeXus file. When
                you open a file, the API provides a file "handle", which then stores the current
                location, i.e. which group and/or data item is currently open. Read and write
                operations then act on the currently open entity. In the following, we walk through
                some parts of a typical NeXus program written in C. See the API section for a more
                complete version.</para>
            <para> First, it is necessary to open the file, specifying whether we want read or write
                access. <example>
                    <title>Open a file</title>
                    <programlisting>#include "napi.h"

 int main()
 {
   NXhandle fileID;
   NXopen ('NXfile.nxs', NXACC_CREATE, &amp;fileID);</programlisting>
                </example> The file is opened with "create" access (implying write access), and the
                API returns a file identifier of type NXhandle. Next, we create an NXentry group to
                contain the scan using NXmakegroup and then open it for access using NXopengroup. <example>
                    <title>Create an entry</title>
                    <programlisting>
NXmakegroup (fileID, "Entry", "NXentry");
NXopengroup (fileID, "Entry", "NXentry");
    </programlisting>
                </example> The plottable data is contained within an NXdata group, which must also
                be created and opened. <example>
                    <title>Create data group</title>
                    <programlisting>
NXmakegroup (fileID, "Data", "NXdata");
NXopengroup (fileID, "Data", "NXdata");</programlisting>
                </example> To create a data item, call NXmakedata, specifying the data name, type
                (NX_FLOAT32), rank (in this case, 1), and length of the array (n_t). Then, it can be
                opened for writing. <example>
                    <title>Create data array</title>
                    <programlisting> NXmakedata (fileID, "time_of_flight", NX_FLOAT32, 1, &amp;n_t);
  NXopendata (fileID, "time_of_flight")</programlisting>
                </example> Then write the data using NXputdata. <example>
                    <title>Write the data</title>
                    <programlisting>  NXputdata (fileID, t);</programlisting>
                </example> With data item is still open, we can also add some data attributes, such
                as the data units, which are specified as a character string (type NX_CHAR) that is
                12 bytes long. <example>
                    <title>Add an attribute</title>
                    <programlisting>NXputattr (fileID, "units", "microseconds", 12, NX_CHAR);</programlisting>
                </example> Then we close the data item before opening another. In fact, the API will
                do this automatically if you attempt to open another data item, but it is better
                style to close it yourself. <example>
                    <title>Close the data array</title>
                    <programlisting>NXclosedata (fileID);</programlisting>
                </example> The remaining data items in this group are added in a similar fashion.
                Note that the indentation whenever a new data item or group are opened is just
                intended to make the structure of the NeXus file more transparent. <example>
                    <title>The rest of the data group</title>
                    <programlisting>    NXmakedata (fileID, "polar_angle", NX_FLOAT32, 1, &amp;n_p);
       NXopendata (fileID, "polar_angle");
         NXputdata (fileID, polar_angle);
         NXputattr (fileID, "units", "degrees", 7, NX_CHAR);
       NXclosedata (fileID);
       dims[0] = n_t;
       dims[1] = n_p;
       NXmakedata (fileID, "counts", NX_INT32, 2, dims);
       NXopendata (fileID, "counts");
         NXputdata (fileID, counts);
       NXclosedata (fileID);</programlisting>
                </example> Finally, close the groups (NXdata and NXentry) before closing the file
                itself. <example>
                    <title>Cleanup</title>
                    <programlisting>   NXclosegroup (fileID);
   NXclosegroup (fileID);
   NXclose (&amp;fileID);
   return;
}</programlisting>
                </example></para>
        </section>
        <section>
            <title>How do I read a NeXus file?</title>
            <para>Reading a NeXus file is almost identical to writing one. Obviously, it is not
                necessary to call NXmakedata since the item already exists, but it is necessary to
                call one of the query routines to find out the rank and length of the data before
                allocating an array to store it.</para>
            <para>Here is part of a program to read the time-of-flight array from the file created
                by the example above. <example>
                    <title>File read example</title>
                    <programlisting> NXopen ('NXfile.nxs', NXACC_READ, &amp;fileID);
   NXopengroup (fileID, "Entry", "NXentry");
     NXopengroup (fileID, "Data", "NXdata");
       NXopendata (fileID, "time_of_flight");
         NXgetinfo (fileID, &amp;rank, dims, &amp;datatype);
         NXmalloc ((void **) &amp;tof, rank, dims, datatype);
         NXgetdata (fileID, tof);
       NXclosedata (fileID);
     NXclosegroup (fileID);
   NXclosegroup (fileID);
 NXclose (fileID);</programlisting>
                </example></para>
            <para>NeXus files can also be viewed by a command-line browser, NXbrowse, which is
                included with the NeXus API. The following is an example session of using NXbrowse
                to view a data file from the LRMECS spectrometer at IPNS. The following commands are
                used (see the NXbrowse web page ): <table>
                    <title>NXbrowse Command Description</title>
                    <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <thead>
                            <row>
                                <entry>Command</entry>
                                <entry>Description</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>dir</entry>
                                <entry>List the contents of the current group</entry>
                            </row>
                            <row>
                                <entry>open Histogram1</entry>
                                <entry>Open the NeXus group "Histogram1"</entry>
                            </row>
                            <row>
                                <entry>read title</entry>
                                <entry>Print the contents of the NeXus data labelled "title"</entry>
                            </row>
                            <row>
                                <entry>close</entry>
                                <entry>Close the current group</entry>
                            </row>
                            <row>
                                <entry>quit</entry>
                                <entry>Quit the browser</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table><example>
                    <title>Using NXbrowse</title>
                    <programlisting>
%> nxbrowse lrcs3701.nxs

NXBrowse 3.0.0. Copyright (C) 2000 R. Osborn, M. Koennecke, P. Klosowski
    NeXus_version = 1.3.3
    file_name = lrcs3701.nxs
    file_time = 2001-02-11 00:02:35-0600
    user = EAG/RO
NX> dir
  NX Group : Histogram1 (NXentry)
  NX Group : Histogram2 (NXentry)
NX> open Histogram1
NX/Histogram1> dir
  NX Data  : title[44] (NX_CHAR)
  NX Data  : analysis[7] (NX_CHAR)
  NX Data  : start_time[24] (NX_CHAR)
  NX Data  : end_time[24] (NX_CHAR)
  NX Data  : run_number (NX_INT32)
  NX Group : sample (NXsample)
  NX Group : LRMECS (NXinstrument)
  NX Group : monitor1 (NXmonitor)
  NX Group : monitor2 (NXmonitor)
  NX Group : data (NXdata)
NX/Histogram1> read title
  title[44] (NX_CHAR) = MgB2 PDOS 43.37g 8K 120meV E0@240Hz T0@120Hz
NX/Histogram1> open data
NX/Histogram1/data> dir
  NX Data  : title[44] (NX_CHAR)
  NX Data  : data[148,750] (NX_INT32)
  NX Data  : time_of_flight[751] (NX_FLOAT32)
  NX Data  : polar_angle[148] (NX_FLOAT32)
NX/Histogram1/data> read time_of_flight
  time_of_flight[751] (NX_FLOAT32) = [ 1900.000000 1902.000000 1904.000000 ...]
    units = microseconds
    long_name = Time-of-Flight [microseconds]
NX/Histogram1/data> read data
  data[148,750] (NX_INT32) = [ 1 1 0 ...]
    units = counts
    signal = 1 
    long_name = Neutron Counts
    axes = polar_angle:time_of_flight
NX/Histogram1/data> close
NX/Histogram1> close
NX> quit</programlisting>
                </example></para>
            <para>The source code provides an example of how to write a NeXus reader. The test
                programs included in the NeXus API may also be useful to study. </para>
        </section>
        <section>
            <title>Where to go from here?</title>
            <para>The other sections of this web site give much more detailed descriptions of the
                NeXus data format. <variablelist>
                    <varlistentry>
                        <term>[[Design|NeXus Design]]TKlink</term>
                        <listitem>
                            <para>This describes NeXus' hierarchical design, and gives more
                                information on how to construct valid groups.</para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>[[Application_Program_Interface|NeXus API]]TKlink</term>
                        <listitem>
                            <para>This describes the NeXus programming interface, with lists of all
                                the subroutines and supported languages</para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>[[MailingLists|NeXus Mailing Lists]]TKlink</term>
                        <listitem>
                            <para>NeXus mailing lists</para>
                        </listitem>
                    </varlistentry>
                </variablelist></para>
        </section>
    </section>

    <!-- NEXUS DESIGN SECTION -->
    <section>
        <title>NeXus Design</title>
        <para>The structure of NeXus files is extremely flexible, allowing the storage both of
            simple data sets, e.g., a single data array and its axes, and also of highly complex
            data, e.g., the simulation results of an entire multi-component instrument. This
            flexibility is achieved through a hierarchical structure, with related data items
            collected together into groups, making NeXus files easy to navigate, even without any
            documentation. NeXus files are self-describing, and should be easy to understand, at
            least by those familiar with the experimental technique.</para>
        <para>The logical design is distinct from the underlying format used to store the NeXus file
            on disk, which are written using the NeXus Application Program Interface (API). Refer to
            the API section for more details.</para>
        <section>
            <title>NeXus Objects</title>
            <para>NeXus data files contain two types of elementary object: data items and data
                groups. In addition, metadata required to describe a data item, e.g. its physical
                units, can be attached to the data as data attributes.</para>
            <section>
                <title>Data Items</title>
                <para>Data items contain the essential information stored in a NeXus file. They can
                    be scalar values or multidimensional arrays of a variety of sizes (1-byte,
                    2-byte, 4-byte, 8-byte) and types (integers, floats, characters). The items may
                    store both experimental results (counts, detector angles, etc), and other
                    information associated with the experiment (start and end times, user names,
                    etc). Data items are identified by their names, which must be unique within the
                    group in which they are stored.</para>
            </section>
            <section>
                <title>Data Attributes</title>
                <para>Attributes are extra (meta-)information that are associated with particular
                    data items. They are used to annotate the data, e.g. with physical units or
                    calibration offsets, and may be scalar numbers or character strings. In
                    addition, NeXus uses attributes to identify plottable data and their axes, etc.
                    Finally, NeXus files themselves have global attributes that identify the NeXus
                    version, file creation time, etc.. Attributes are identified by their names,
                    which must be unique in each data item.</para>
            </section>
            <section>
                <title>Data Groups</title>
                <para>NeXus files consist of data groups, which contain data items and/or other
                    groups to form a hierarchical structure. This hierarchy is designed to make it
                    easy to navigate a NeXus file by storing related data items together. Data
                    groups are identified both by a name, which must be unique within a particular
                    group, and a class. There can be multiple groups with the same class.</para>
            </section>
        </section>
        <section>
            <title>NeXus Classes</title>
            <para>Data groups often describe objects in the experiment (monitors, detectors,
                monochromators, etc.), so that the contents (both data items and/or other data
                groups) comprise the properties of that object. NeXus has defined a set of standard
                objects, or classes, out of which a NeXus file can be constructed. Each data group
                is therefore identified by a name and a class. The group class, which always has
                "NX" as a prefix, defines the type of object and the properties that it can contain,
                whereas the group name defines a unique instance of that class. These classes are
                defined in XML using the NeXus MetaDTD format. </para>
            <para>Not all classes define physical objects. Some refer to logical groupings of
                experimental information, such as plottable data, sample environment logs, beam
                profiles, etc.</para>
            <para>The following table shows the hierarchy of a standard NeXus file, and where groups
                of a particular class are located. There can be multiple instances of each class. On
                the other hand, a typical NeXus file will only contain a small subset of the
                possible classes.</para>
            <section>
                <title>NeXus Data</title>
                <para>One of the aims of the NeXus design was to make it possible to separate the
                    measured data in a NeXus file from all the metadata that describe how that
                    measurement was performed. In principle, it should be possible for a plotting
                    utility to identify the plottable data automatically (or to provide a list of
                    choices if there is more than one set of data). In order to distinguish the
                    actual measurements from this metadata, it is stored separately in groups with
                    the class NXdata. These groups encapsulate all the information required to
                    produce a meaningful plot, including any error arrays and axis scales, i.e. the
                    physical values corresponding to the data dimensions.</para>
                <para>The NXdata groups have to be flexible enough to cope with data of arbitrary
                    rank and provide a mechanism for associating axis scales with the appropriate
                    dimension of data. We use data attributes to accomplish this. Here are the main
                    rules that must be followed in constructing an NXdata group. <itemizedlist>
                        <listitem>
                            <para>Each NXdata group will consist of only one data set containing
                                plottable data and their standard deviations.</para>
                        </listitem>
                        <listitem>
                            <para>The data set will be identified by an attribute of "signal" given
                                a value 1. </para>
                        </listitem>
                        <listitem>
                            <para>This data set may be of arbitrary rank. </para>
                        </listitem>
                    </itemizedlist> If available, the standard deviations of the data are to be
                    stored in a data set of the same rank and dimensions, with the name "errors". <itemizedlist>
                        <listitem>
                            <para>For each data dimension, there should be a one-dimensional array
                                of the same length. </para>
                        </listitem>
                        <listitem>
                            <para>These one-dimensional arrays are the "dimension scales" of the
                                data i.e. the values of the independent variables at which the data
                                is measured e.g. scattering angle or energy transfer. </para>
                        </listitem>
                    </itemizedlist>
                </para>
                <para>There are two methods of linking each data dimension to its respective
                    dimension scale. <orderedlist>
                        <listitem>
                            <para> The first method is to define an attribute of each dimension
                                scale called "axis". It is an integer whose value is the number of
                                the dimension, in order of fastest varying dimension. i.e. if the
                                array being stored is data, with elements data[j][i] in C and
                                data(i,j) in Fortran, where i is the time-of-flight index and j is
                                the polar angle index, the NXdata group would contain : <example>
                                    <title>Old way of denoting axes</title>
                                    <programlisting><![CDATA[<NXdata name=" data " > 
         <time_of_flight axis= 1 primary= 1 > 1500.0 1502.0 1504.0 … </time_of_flight> 
         <polar_angle axis= 2 primary= 1 > 15.0 15.6 16.2 … </polar_angle> 
         <data > 5 7 14 … </data> 
</NXdata>]]></programlisting>
                                </example> This attribute must be defined for each dimension scale.
                            </para>
                        </listitem>
                        <listitem>
                            <para>The second method is to define an attribute of the data itself
                                called "axes". It contains the names of each dimensions scale as a
                                comma- or colon-delimited list in the order they appear in C.
                                Optionally, the list can be enclosed in brackets, but should not
                                contain any spaces, e.g. <example>
                                    <title>Preferred way of denoting axes</title>
                                    <programlisting><![CDATA[<NXdata name=" data " > 
         <time_of_flight > 1500.0 1502.0 1504.0 … </time_of_flight> 
         <polar_angle > 15.0 15.6 16.2 … </polar_angle> 
         <data axes="polar_angle:time_of_flight" > 5 7 14 … </data> 
</NXdata>]]></programlisting>
                                </example>
                            </para>
                        </listitem>
                    </orderedlist> The second method is required when the dimension scale is used in
                    more than one NXdata group in a different context, e.g. it is used as the x-axis
                    in one group and the y-axis in another. </para>
                <para>The first method was historically the first to be used, but the second is now
                    recommended for future applications. However, both will be supported in NeXus
                    utilities that identify dimension scales, e.g. NXUfindaxis. </para>
                <para>There are limited circumstances in which more than one dimension scale for the
                    same data dimension can be included in the same NXdata group. The most common is
                    when they are the three components of an (hkl) scan. In order to handle this
                    case, we have defined another attribute of type integer called "primary" whose
                    value determines the order in which the scale is expected to be chosen for
                    plotting, i.e. 1st choice: primary = 1 2nd choice: primary = 2 etc. If there is
                    more than one scale with the same value of the "axis" attribute, one of them
                    must have the "primary" attribute set to 1. Defining the "primary" attribute for
                    the other scales is optional.</para>

                <para>N.B. The "primary" attribute can only be used with the first method of
                    defining dimension scales discussed above. In addition to the signal data, this
                    group could contain a data set of the same rank and dimensions called "errors"
                    containing the standard deviations of the data.</para> 

                <para>It is often (usually) necessary to associate the data and/or axis scales with
                    other metadata stored in other groups, e.g. the NXsample group or components of
                    the NXinstrument group. For example, it may be necessary to perform corrections
                    for the detector efficiency using information stored in the associated
                    NXdetector group. In this case, it is recommended that the relevant arrays are
                    initially stored in those groups, and then linked to the NXdata group. The API
                    will provide a mechanism for identifying the parent group so that the relevant
                    metadata can be accessed. </para>
                <para>Here is a simple example to illustrate the concept: <example>
                        <title>Abbreviated NeXus file</title>
                        <programlisting><![CDATA[<NXentry name="entry">
    <NXsample name="sample">
        <magnetic_field link="/entry/sample">10.0</magnetic_field>
    </NXsample>
    <NXinstrument name="instrument">
        <NXdetector name="detector">
            <data axes=" time_of_flight:magnetic_field " link="/entry/instrument/detector">5 7 14 etc </data>
            <time_of_flight link="/entry/instrument/detector ">1500.0 1502.0 1504.0 etc </time_of_flight>
        </NXdetector>
    </NXinstrument>
    <NXdata>
        <data axes="time_of_flight:magnetic_field" link="/entry/instrument/detector">{link to values in NXdetector}</data>
        <time_of_flight link="/entry/instrument/detector">{link to values in NXdetector}</time_of_flight>
        <magnetic_field link="/entry/sample">{link to values in NXsample}</magnetic_field>
    </NXdata>
</NXentry>]]></programlisting>
                    </example>
                </para>
                <para>The general principle is that physical quantites are stored in the groups that
                    they refer to (e.g. counts in NXdetector, temperature in NXsample) and these
                    quantities are then linked into NXdata for interpretation. In this example,
                    there are two axis scales, "magnetic_field" and "time_of_flight", which are
                    stored in NXsample and NXdetector groups respectively. A program is able to use
                    the information in the "link" attribute to locate the respective groups. One
                    corollary of this is that there should be one NXdetector group for each NXdata
                    group, e.g. one for each detector bank in a multi-bank instrument.</para>
                <para>The syntax of the "link" attribute requires a bit of explanation. Under HDF4
                    you can only create, what would be called under UNIX, "hard links". Hard links
                    have the characteristics that: <itemizedlist>
                        <listitem>
                            <para>The name of the entity must be the same in both the original and
                                linked groups </para>
                        </listitem>
                        <listitem>
                            <para>The attributes of both the origial entity and the linked one are
                                the same </para>
                        </listitem>
                        <listitem>
                            <para>You cannot distinguish the original entity from the linked
                            one</para>
                        </listitem>
                        <listitem>
                            <para>You cannot follow a link - it is like an inode in a filesystem and
                                just points at the data </para>
                        </listitem>
                    </itemizedlist>
                </para>
                <para>To overcome this and allow us to link from NXdata to, say, NXsample and to
                    know that the original data belongs to NXsample we write the "link" attribute
                    that contains the path of the original group containing it. All linked entities
                    will share this "link" attribute and thus can use it to locate the original
                    source group. We are effectively using the "link" attribute to simulate
                    "symbolic links". So in the above example both the original "time_of_flight" and
                    the linked one will share a link attribute containing the text
                    "/entry/instrument/detector" because "/entry/instrument/detector/time_of_flight"
                    is the original instance.</para>
            </section>
            <section>
                <title>NeXus Attributes</title>
                <table>
                    <title>Global Attributes</title>
                    <tgroup cols="3" align="left" colsep="1" rowsep="1">
                        <thead>
                            <row>
                                <entry>Name</entry>
                                <entry>Type</entry>
                                <entry>Description</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>file_name</entry>
                                <entry>NX_CHAR</entry>
                                <entry>File name of original NeXus file to assist in identification
                                    if the external name has been changed</entry>
                            </row>
                            <row>
                                <entry>file_time</entry>
                                <entry>ISO 8601</entry>
                                <entry>Date and time of file creation</entry>
                            </row>
                            <row>
                                <entry>file_update_time</entry>
                                <entry>ISO 8601</entry>
                                <entry>Date and time of last file change at close</entry>
                            </row>
                            <row>
                                <entry>NeXus_version</entry>
                                <entry>NX_CHAR</entry>
                                <entry>Version of NeXus API used in writing the file</entry>
                            </row>
                            <row>
                                <entry>creator</entry>
                                <entry>NX_CHAR</entry>
                                <entry>Facility or program where the file originated</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
                <table>
                    <title>Data Attributes</title>
                    <tgroup cols="3" align="left" colsep="1" rowsep="1">
                        <thead>
                            <row>
                                <entry>Name</entry>
                                <entry>Type</entry>
                                <entry>Description</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>units</entry>
                                <entry>NX_CHAR</entry>
                                <entry>Units of data which must conform to the standard defined by
                                    the Unidata UDunits utility (in particular, see
                                udunits.dat)</entry>
                            </row>
                            <row>
                                <entry>signal</entry>
                                <entry>NX_INT32</entry>
                                <entry>Defines which data set contains the signal to be plotted -
                                    set to 1 for main signal</entry>
                            </row>
                            <row>
                                <entry>axes</entry>
                                <entry>NX_CHAR</entry>
                                <entry>Defines the names of the dimension scales for this data set
                                    as a comma-delimited array, optionally surrounded by brackets
                                    (see a longer discussion in the section on NXdata structure)
                                    i.e. if the array being stored is <code>data</code>, with
                                    elements <code>data[j][i]</code> in C and <code>data(i,j)</code>
                                    in Fortran, with dimension scales <code>time_of_flight[i]</code>
                                    and <code>polar_angle[j]</code>, <code>data</code> would have an
                                    attribute called "axes" with the following value :
                                        <code>[polar_angle,time_of_flight]</code></entry>
                            </row>
                            <row>
                                <entry>axis</entry>
                                <entry>NX_INT32</entry>
                                <entry>As an alternative to using the "axes" attribute, this defines
                                    the rank of the signal data for which this data set is a
                                    dimension scale in order of the fastest varying index (see a
                                    longer discussion in the section on NXdata structure) i.e. if
                                    the array being stored is <code>data</code>, with elements
                                        <code>data[j][i]</code> in C and <code>data(i,j)</code> in
                                    Fortran, "axis" would have the following values: ith dimension
                                    (axis = 1), jth dimension (axis = 2), etc. </entry>
                            </row>
                            <row>
                                <entry>primary</entry>
                                <entry>NX_INT32</entry>
                                <entry>Defines the order of preference for dimension scales which
                                    apply to the same rank of signal data - set to 1 for preferred
                                    dimension scale</entry>
                            </row>
                            <row>
                                <entry>long_name</entry> 	<entry>NX_CHAR</entry> 	<entry>Defines title of signal data or axis label of dimension scale</entry>
                            </row>
                            <row>
                                <entry>calibration_status</entry> 	<entry>NX_CHAR</entry> 	<entry>Defines status of data value - set to "Nominal" or "Measured"</entry>
                            </row>
                            <row>
                                <entry>histogram_offset</entry> 	<entry>NX_FLOAT32</entry> 	<entry>Defines the offset from the first data point to its bin boundary.
i.e. left_bin = data[1] - histogram_offset

- set to 0 if the data are not histograms. The points themselves should be set to the bin centers. For reasoning behind this design, see note on histograms.</entry>
                            </row>
                            <row>
                                <entry>checksum</entry> 	<entry>NX_INT32</entry> 	<entry>Sum of data array acting as a check on data integrity</entry>
                            </row>
                            <row>
                                <entry>version</entry> 	<entry>NX_CHAR</entry> 	<entry>Version of XML DTD file or schema on which the NeXus file is based. Should only be used with the "analysis" data item in an NXentry group.</entry>
                            </row>
                            <row>
                                <entry>URL</entry> 	<entry>NX_CHAR</entry> 	<entry>The URL of the XML DTD file or schema on which the NeXus file is based. Should only be used with the "analysis" data item in an NXentry group.</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </section>
        </section>
    </section>

    <!-- NEXUS INSTRUMENTS -->
    <section>
        <title>NeXus Instruments</title>
        <para>The NeXus Design page lists the group classes from which a NeXus file is constructed.
            They provide the glossary of items that could, in principle, be stored in a
            standard-conforming NeXus file (other items may be inserted into the file if the author
            wishes, but they won't be part of the standard). If you are going to include a
            particular piece of metadata, consult the class definitions to find out what to call it.
            However, to assist those writing data analysis software, it is useful to provide more
            than a glossary; it is important to define the required contents of NeXus files that
            contain data from particular classes of neutron, x-ray, or muon instrument.</para>
        <para>As part of the NeXus standard, we have identified a number of generic instruments that
            describe an appreciable number of existing instruments around the world. Although not
            identical in every detail, they share enough common characteristics, and more
            importantly, they require sufficiently similar modes of data analysis, to make a
            standard description useful. They are in the process of being defined for the NeXus
            standard. The definitions will be in XML using the NeXus Meta-DTD format.</para>
    </section>

    <!-- FAQ -->
    <section><title>Frequently Asked Questions</title><para>This is a list of commonly asked
            questions concerning the NeXus data format.</para>
        <qandaset>
            <qandaentry>
                <question>
                    <para>How many facilities use NeXus?</para>
                </question>
                <answer>
                    <para>This is continually evolving. It has been used as the instrument format
                        for several years on some or all instruments at a number of facilities
                        including PSI (Switzerland), LLB (France), and LANSCE (USA). It will be used
                        on all future instrumentation at ISIS (UK), NIST (USA), ANSTO (Australia)
                        and instruments using the new data acquisition system at IPNS (USA).
                        Finally, it has been formally adopted by major facilities under
                        construction, the SNS (USA), JPARC (Japan) and Diamond Light Source
                    (UK).</para>
                </answer>
            </qandaentry>
            <qandaentry>
                <question>
                    <para>NeXus files are only useful for archiving instrumental data, aren't
                    they?</para>
                </question>
                <answer>
                    <para>NeXus files can be used to store both extremely simple data, e.g. a single
                        (x,y) array, and highly complex instrument descriptions. In fact, the
                        original intention of the NeXus data format was to provide a way of
                        interchanging data between facilities and their user communities. However,
                        the power of NeXus hierarchical design has led to its adoption as a standard
                        archiving format by several major facilities, such as ISIS, LANSCE, and the
                        SNS.</para>
                </answer>
            </qandaentry>
            <qandaentry>
                <question>
                    <para>Why aren't NXsample and NXmonitor groups stored in the NXinstrument
                    group?</para>
                </question>
                <answer>
                    <para>A NeXus file can contain a number of NXentry groups, which may represent
                        different scans in an experiment, or sample and calibration runs, etc. In
                        many cases, though by no means all, the instrument has the same
                        configuration so that it would be possible to save space by storing the
                        NXinstrument group once and using multiple links in the remaining NXentry
                        groups. It is assumed that the sample and monitor information would be more
                        likely to change from run to run, and so should be stored at the top
                    level.</para>
                </answer>
            </qandaentry>
            <qandaentry>
                <question>
                    <para>How do I identify the plottable data?</para>
                </question>
                <answer>
                    <para>Any program whose aim is to identify plottable data should use the
                        following procedure: <orderedlist>
                            <listitem>
                                <para>Open the first top level NeXus group with class
                                NXentry.</para>
                            </listitem>
                            <listitem>
                                <para>Open the first NeXus group with class NXdata.</para>
                            </listitem>
                            <listitem>
                                <para>Loop through NeXus data items in this group searching for the
                                    item with attribute "signal" =1. This is the plottable
                                data.</para>
                            </listitem>
                            <listitem>
                                <para>Check to see if this data item has an attribute called "axes".
                                    If so, the names are defined as a comma-delimited string within
                                    this attribute in the C-order of the data array, and you can
                                    skip the next two steps.</para>
                            </listitem>
                            <listitem>
                                <para>If the "axes" attribute is not defined, search for the
                                    one-dimensional NeXus data items with attribute "primary" =
                                1.</para>
                            </listitem>
                            <listitem>
                                <para>These are the dimension scales to label the axes of each
                                    dimension of the data.</para>
                            </listitem>
                            <listitem>
                                <para>Link each dimension scale to the respective data dimension by
                                    the "axis" attribute (= 1,2,...,rank of data).</para>
                            </listitem>
                            <listitem>
                                <para>If necessary, close the NXdata group, open the next one and
                                    repeat steps 3 to 6.</para>
                            </listitem>
                            <listitem>
                                <para>If necessary, close the NXentry group, open the next one and
                                    repeat steps 2 to 7. </para>
                            </listitem>
                        </orderedlist> Consult the NeXus API section, which describes the routines
                        available to program these operations. In the course of time, generic NeXus
                        browsers will provide this functionality automatically. </para>
                </answer>
            </qandaentry>
            <qandaentry>
                <question>
                    <para>Why are the NeXus classes so complicated? I'll never store all that
                        information</para>
                </question>
                <answer>
                    <para>The NeXus classes are essentially glossaries of terms. If you need to
                        store a piece of information, consult the class definitions to see if it has
                        been defined. If so, use it. However, it is not compulsory to include every
                        item that has been defined if it is not relevant to your experiment. On the
                        other hand, if there is an NeXus definition for your instrument, you are
                        recommended to include all the compulsory items if you want to use standard
                        software to analyze your data.</para>
                </answer>
            </qandaentry>
            <qandaentry>
                <question>
                    <para>I want to produce an instrument definition. How do I go about it?</para>
                </question>
                <answer>
                    <para>The first thing is to check whether the instrument you are interested in
                        is already being defined by an instrument editor. Check the list on the
                        NeXus Instruments page. The NeXus International Advisory Committee is
                        responsible for appointing editors of special interest groups that wish to
                        become a part of the standard, so contact the Executive Secretary, if a
                        group does not yet exist. Of course, if you want to produce your own private
                        definition for personal use, you are free to do so without our approval
                        although we encourage people to share what they are doing . If you are an
                        editor, the process of defining an instrument should be quite simple: <orderedlist>
                            <listitem>
                                <para>Make sure that the data you wish to analyze are stored in
                                    NXdata groups. The rest of the definition is to supply what is
                                    necessary for simple analysis of the data, for example, the
                                    detector positions and incident wavelength for a x-ray powder
                                    diffraction measurement. </para>
                            </listitem>
                            <listitem>
                                <para>Study the base classes to decide which ones are essential for
                                    your definition. If you believe that a new base class is needed,
                                    contact the NIAC with a proposal. </para>
                            </listitem>
                            <listitem>
                                <para>Select those data items and groups that you consider important
                                    in analyzing data from your instrument. </para>
                            </listitem>
                        </orderedlist> Insert the relevant grep character, as defined in the NeXus
                        Meta-DTD format to denote the number of occurrences. If the item is optional
                        ("?" or "*"), then it does not need to be added to your definition.</para>
                    <para>If you encounter any problems because the classes are not sufficient to
                        describe your configuration, please contact the NIAC Executive Secretary
                        explaining the problem, and post a suggestion at the relevant class wiki
                        page. The NIAC is always willing to consider proposals to amend the base
                        classes. The procedures are defined in the NIAC constitution. </para>
                </answer>
            </qandaentry>
        </qandaset>
    </section>
</chapter>
