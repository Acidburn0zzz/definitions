<?xml version="1.0" encoding="UTF-8"?>
<?oxygen RNGSchema="http://www.oasis-open.org/docbook/xml/5.0/rng/docbook.rng" type="xml"?>
<!-- # $Id$ -->
<chapter xml:id="MediaWikiManualChapter" xmlns="http://docbook.org/ns/docbook" version="5.0"
    xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude">
    <title>MediaWiki Manual</title>
    <!--
        Note there is WWW-based converter from MediaWiki to DocBook:
            http://toolserver.org/~magnus/wiki2xml/w2x.php
    -->
    <!-- NEXUS INTRODUCTION SECTION -->
    <section xml:id="NeXusIntroductionSection">
        <title>NeXus Introduction</title>
        <para>In recent years, a number of scientists and computer programmers working in neutron
            and synchrotron facilities around the world came to the conclusion that a common data
            format would fulfil a valuable function in the scattering community. As instrumentation
            becomes more complex and data visualization become more challenging, individual
            scientists, or even institutions, have found it difficult to keep up with new
            developments. A common data format makes it easier, both to exchange experimental
            results and to exchange ideas about how to analyze them. It promotes greater cooperation
            in software development and stimulate the design of more sophisticated visualization
            tools. For additional background information see the chapter titled
            <!-- link method: 
                http://www.sagehill.net/docbookxsl/Db5Tools.html
                "Internal link with literal text"
                also suggested reading: http://www.w3.org/TR/xlink/ 
            -->
                "<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#BriefHistoryChapter"
                >Brief history of the NeXus format</link>." </para>
        <para>This section is designed to give a brief introduction to NeXus, the data format that
            has been developed in response to these needs. It explains what a modern data format
            such as NeXus is and how to write simple programs to read and write NeXus files. </para>
        <section xml:id="WhatIsNeXusSection">
            <title>What is NeXus?</title>
            <para>The NeXus
                <indexterm significance="preferred"><primary>NeXus</primary></indexterm>
                data format has four components: <variablelist>
                    <varlistentry>
                        <term>A set of subroutines</term>
                        <listitem>
                            <para>to make it easy to read and write NeXus files.</para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>A set of design principles</term>
                        <listitem>
                            <para>to help people understand what is in them.</para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>A set of instrument definitions</term>
                        <listitem>
                            <para>to allow the development of more portable analysis
                                software.</para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>A set of low-level file formats</term>
                        <listitem>
                            <para>to actually store NeXus files on physical media.</para>
                        </listitem>
                    </varlistentry>
                </variablelist></para>
            <section>
                <title>A Set of Subroutines</title>
                <para>In the past, a data format was defined by a document describing the precise
                    location of every item in the data file, either as row and column numbers in an
                    ASCII file, or as record and byte numbers in a binary file. In modern data
                    formats, such as NeXus, the user does not need to know where the data are
                    stored, just what they are called. It is the job of the subroutine library to
                    retrieve the data.</para>
                <para>For example, in NeXus, a program to read in the wavelength of an experiment
                    would contain lines similar to the following: <example>
                        <title>Simple example of reading data</title>
                        <indexterm><primary>example</primary><secondary>simple</secondary></indexterm>
                        <programlisting language="c">NXopendata (fileID, "wavelength");
NXgetdata (fileID, lambda);
NXclosedata (fileID);
</programlisting>
                    </example> In this example, the program requests the value of the data that has
                    the label <code>wavelength</code>, storing the result in the variable lambda.
                        <code>fileID</code> is a file identifier that is provided by NeXus when the
                    file is opened. </para>
                <para>We shall provide a more complete example when we have discussed the contents
                    of the NeXus files.</para>
            </section>
            <section>
                <title>A Set of Design Principles</title>
                <para>NeXus data files
                    <indexterm>
                        <primary>NeXus</primary>
                        <secondary>Design Principles</secondary>
                    </indexterm>
                    contain two types of entity: data items and data groups. <variablelist>
                        <varlistentry>
                            <term>Data Items</term>
                            <listitem>
                                <para>These can be scalar values or multidimensional arrays of a
                                    variety of sizes (1-byte, 2-byte, 4-byte, 8-byte) and types
                                    (characters, integers, floats). Extra information required to
                                    describe a particular data item, such as the data units, can be
                                    stored as a data attribute. </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>Data Groups</term>
                            <listitem>
                                <para>These are like folders that can contain a number of data items
                                    and/or other groups.</para>
                            </listitem>
                        </varlistentry>
                    </variablelist></para>
                <para>In fact, a NeXus file can be viewed as a computer file system. Just as files
                    are stored in folders (or subdirectories) to make them easy to locate, so NeXus
                    data items are stored in groups. The group hierarchy is designed to make it easy
                    to navigate a NeXus file.</para>
                <section>
                    <title>Example of a NeXus File</title>
                    <para>The following diagram shows an example of a NeXus file represented as a
                        tree structure. <figure>
                            <title>Example of a NeXus file</title>
                            <mediaobject>
                                <imageobject>
                                    <imagedata fileref="img/Hierarchy.gif" width="400pt" scalefit="1"/>
                                </imageobject>
                            </mediaobject>
                        </figure> Note that each data item is identified by a name, e.g., counts,
                        but each group is identified both by a name and, in parentheses, a class
                        identifier, e.g., monitor (NXmonitor). The class names, which all begin with
                        NX, define the sort of data items that the group should contain, in this
                        case, counts from a beamline monitor. The hierarchical design, with data
                        items nested in groups, makes it easy to identify information if you are
                        browsing through a file. </para>
                </section>
                <section>
                    <title>Important Classes</title>
                    <para>Here are some of the important classes found in nearly all NeXus files. A
                        complete list can be found in the <link
                            xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#DesignSection"
                            >NeXus Design section</link>
                        <variablelist>
                            <varlistentry>
                                <term>NXentry</term>
                                <listitem>
                                    <para>The top level of any NeXus file contains one or more
                                        groups with the class <code>NXentry</code>.
                                        <indexterm>
                                            <primary>classes</primary>
                                            <secondary>base classes</secondary>
                                            <tertiary>NXentry</tertiary>
                                        </indexterm>
                                        These contain all the data
                                        that is required to describe an experimental run or scan.
                                        Each <code>NXentry</code> typically contains a number of groups
                                        describing sample information (class <code>NXsample</code>), instrument
                                        details (class <code>NXinstrument</code>), and monitor counts (class
                                        <code>NXmonitor</code>). </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term>NXdata</term>
                                <listitem>
                                    <para>Each <code>NXentry</code> group contains one or more groups with class
                                        <code>NXdata</code>.
                                        <indexterm>
                                            <primary>classes</primary>
                                            <secondary>base classes</secondary>
                                            <tertiary>NXdata</tertiary>
                                        </indexterm>
                                        These groups contain the experimental results in a
                                        self-contained way, i.e., it should be possible to generate
                                        a sensible plot of the data from the information contained
                                        in each <code>NXdata</code> group. That means it should contain the axis
                                        labels and titles as well as the data.</para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term>NXsample</term>
                                <listitem>
                                    <para>A <code>NXentry</code> group will often contain a group with class
                                        <code>NXsample</code>.
                                        <indexterm>
                                            <primary>classes</primary>
                                            <secondary>base classes</secondary>
                                            <tertiary>NXsample</tertiary>
                                        </indexterm>
                                        This group contains information pertaining to the
                                        sample, such as its chemical composition, mass, and
                                        environment variables (temperature, pressure, magnetic
                                        field, etc.).</para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term>NXinstrument</term>
                                <listitem>
                                    <para>There might also be a group with class <code>NXinstrument</code>.
                                        <indexterm>
                                            <primary>classes</primary>
                                            <secondary>base classes</secondary>
                                            <tertiary>NXinstrument</tertiary>
                                        </indexterm>
                                        This
                                        is designed to encapsulate all the instrumental information
                                        that might be relevant to a measurement, such as flight
                                        paths, collimations, chopper frequencies, etc.</para>
                                </listitem>
                            </varlistentry>
                        </variablelist><figure>
                            <title>NXinstrument excerpt</title>
                            <mediaobject>
                                <imageobject>
                                    <imagedata fileref="img/NXinstrument.gif" width="300pt" scalefit="1"/>
                                </imageobject>
                            </mediaobject>
                        </figure> Since an instrument can comprise several beamline components each
                        defined by several parameters, they are each specified by a separate group.
                        This hides the complexity from generic file browsers, but makes the
                        information available in an intuitively obvious way if it is required.
                    </para>
                </section>
                <section>
                    <title>Simple Example</title>
                    <para>NeXus data files do not need to be complicated.
                        In fact, the following
                        diagram shows an extremely simple NeXus file that could be used to transfer
                        data between programs. <figure>
                            <title>Simple Example</title>
                            <mediaobject>
                                <imageobject>
                                    <imagedata fileref="img/Simple.gif" width="400pt" scalefit="1"/>
                                </imageobject>
                            </mediaobject>
                        </figure> This illustrates the fact that the structure of NeXus files is
                        extremely flexible. It can accommodate very complex instrumental
                        information, if required, but it can also be used to store very simple data
                        sets. </para>
                </section>
            </section>
            <section>
                <title>A Set of Instrument Definitions</title>
                <para>If the design principles are followed, it will be easy for anyone browsing a
                    NeXus file to understand what it contains, without any prior information.
                    However, if you are writing visualization or analysis software, you will need to
                    know precisely what information is contained in advance. For that reason, NeXus
                    provides a way of defining the format for particular instrument types,
                    <indexterm>
                        <primary>instrument definitions</primary>
                    </indexterm>
                    e.g.,
                    time-of-flight small angle neutron scattering. This requires some agreement by
                    the relevant communities, but would allow the development of much more portable
                    software.</para>
                <para>These instrument definitions are being formalized as XML files, using a
                    specially devised syntax that specifies the names of data items, and whether
                    they are optional or required. The following is an example of such a file for
                    the simple NeXus file shown above. 
                    <example>
                        <title><citetitle>verysimple.xml</citetitle>: A very simple NeXus file</title>
                        <indexterm><primary>example</primary><secondary>very simple</secondary></indexterm>
                        <programlisting language="xml" linenumbering="numbered"
                            ><xi:include href="verysimple.xml" parse="text"
                            /></programlisting></example> 
                    If you want to define the format of a particular type of NeXus file
                    for your own use, e.g. as the standard output from a program, you are encouraged
                    to "publish" the format using this XML format. </para>
            </section>
            <section>
                <title>A Set of Low-Level File Formats</title>
                <para>To actually store NeXus files on physical media, different low-level file
                    formats
                    <indexterm>
                        <primary>NeXus</primary>
                        <secondary>low-level file formats</secondary>
                    </indexterm>
                    are available, namely HDF4, HDF5, and XML. The NeXus library may be
                    configured to support all of them, or any nonempty subset. Applications that
                    create NeXus files need to decide (or let the user decide) in which low-level
                    format data shall be stored. Generic data analysis applications should be able
                    to read any low-level format.</para>
            </section>
        </section>
        <section xml:id="ApplicationProgramInterfaceSection">
            <title>The NeXus Application Programming Interface (API)</title>
            <para>The NeXus API consists of routines to read and write NeXus data files.</para>
            <section>
                <title>How do I write a NeXus file?</title>
                <para>The NeXus Application Program Interface (API)
                    <indexterm>
                        <primary>NeXus</primary>
                        <secondary>NAPI</secondary>
                    </indexterm>
                    <indexterm>
                        <primary>NAPI</primary>
                        <secondary>NeXus, NAPI</secondary>
                    </indexterm>
                    provides a set of subroutines
                    that make it easy to read and write NeXus files. These subroutines are available
                    in C, Fortran 77, Fortran 90, Java, and IDL. Access from other languages, such
                    as Python, is anticipated in the near future. It is also possible to read NeXus
                    files in a number of data analysis tools, such as LAMP, ISAW, and Open
                    GENIE.</para>
                <para>The API uses a very simple "state" model to navigate through a NeXus file.
                    When you open a file, the API provides a file "handle", which then stores the
                    current location, i.e. which group and/or data item is currently open. Read and
                    write operations then act on the currently open entity. In the following, we
                    walk through some parts of a typical NeXus program written in C. See the <link
                        xmlns:xlink="http://www.w3.org/1999/xlink"
                        xlink:href="#ApplicationProgramInterfaceChapter">NeXus API chapter</link>
                    for a more complete version. </para>
                <para>First, it is necessary to open the file, specifying whether we want read or
                    write access. <example>
                        <title>Open a file</title>
                        <indexterm><primary>example</primary><secondary>NAPI</secondary></indexterm>
                        <programlisting language="c">#include "napi.h"

 int main()
 {
   NXhandle fileID;
   NXopen ('NXfile.nxs', NXACC_CREATE, &amp;fileID);</programlisting>
                    </example> The file is opened with "create" access (implying write access), and
                    the API returns a file identifier of type NXhandle. Next, we create an <code>NXentry</code>
                    group to contain the scan using NXmakegroup and then open it for access using
                    NXopengroup. <example>
                        <title>Create an entry</title>
                        <programlisting language="c">NXmakegroup (fileID, "Entry", "NXentry");
NXopengroup (fileID, "Entry", "NXentry");
    </programlisting>
                    </example> The plottable data is contained within an NXdata group, which must
                    also be created and opened. <example>
                        <title>Create data group</title>
                        <programlisting language="c">NXmakegroup (fileID, "Data", "NXdata");
NXopengroup (fileID, "Data", "NXdata");</programlisting>
                    </example> To create a data item, call <code>NXmakedata</code>, specifying the data name,
                    type (NX_FLOAT32), rank (in this case, 1), and length of the array (n_t). Then,
                    it can be opened for writing. <example>
                        <title>Create data array</title>
                        <programlisting language="c"> NXmakedata (fileID, "time_of_flight", NX_FLOAT32, 1, &amp;n_t);
  NXopendata (fileID, "time_of_flight")</programlisting>
                    </example> Then write the data using NXputdata. <example>
                        <title>Write the data</title>
                        <programlisting language="c">  NXputdata (fileID, t);</programlisting>
                    </example> With data item is still open, we can also add some data attributes,
                    such as the data units, which are specified as a character string (type NX_CHAR)
                    that is 12 bytes long. <example>
                        <title>Add an attribute</title>
                        <programlisting language="c"
                            >NXputattr (fileID, "units", "microseconds", 12, NX_CHAR);</programlisting>
                    </example> Then we close the data item before opening another. In fact, the API
                    will do this automatically if you attempt to open another data item, but it is
                    better style to close it yourself. <example>
                        <title>Close the data array</title>
                        <programlisting language="c">NXclosedata (fileID);</programlisting>
                    </example> The remaining data items in this group are added in a similar
                    fashion. Note that the indentation whenever a new data item or group are opened
                    is just intended to make the structure of the NeXus file more transparent. <example>
                        <title>The rest of the data group</title>
                        <programlisting linenumbering="numbered" language="c"
                            >    NXmakedata (fileID, "polar_angle", NX_FLOAT32, 1, &amp;n_p);
       NXopendata (fileID, "polar_angle");
         NXputdata (fileID, polar_angle);
         NXputattr (fileID, "units", "degrees", 7, NX_CHAR);
       NXclosedata (fileID);
       dims[0] = n_t;
       dims[1] = n_p;
       NXmakedata (fileID, "counts", NX_INT32, 2, dims);
       NXopendata (fileID, "counts");
         NXputdata (fileID, counts);
       NXclosedata (fileID);</programlisting>
                    </example> Finally, close the groups (NXdata and <code>NXentry</code>) before closing the
                    file itself. <example>
                        <title>Cleanup</title>
                        <programlisting language="c">   NXclosegroup (fileID);
   NXclosegroup (fileID);
   NXclose (&amp;fileID);
   return;
}</programlisting>
                    </example></para>
            </section>
            <section>
                <title>How do I read a NeXus file?</title>
                <para>Reading a NeXus file is almost identical to writing one. Obviously, it is not
                    necessary to call <code>NXmakedata</code> since the item already exists, but it is necessary
                    to call one of the query routines to find out the rank and length of the data
                    before allocating an array to store it.</para>
                <para>Here is part of a program to read the time-of-flight array from the file
                    created by the example above. <example>
                        <title>File read example</title>
                        <programlisting linenumbering="numbered" language="c"
                            > NXopen ('NXfile.nxs', NXACC_READ, &amp;fileID);
   NXopengroup (fileID, "Entry", "NXentry");
     NXopengroup (fileID, "Data", "NXdata");
       NXopendata (fileID, "time_of_flight");
         NXgetinfo (fileID, &amp;rank, dims, &amp;datatype);
         NXmalloc ((void **) &amp;tof, rank, dims, datatype);
         NXgetdata (fileID, tof);
       NXclosedata (fileID);
     NXclosegroup (fileID);
   NXclosegroup (fileID);
 NXclose (fileID);</programlisting>
                    </example></para>
                <para>NeXus files can also be viewed by a command-line browser, <code>NXbrowse</code>, which is
                    included with the <link xmlns:xlink="http://www.w3.org/1999/xlink"
                        xlink:href="#ApplicationProgramInterfaceSection">NeXus API</link>. The
                    following is an example session of using <code>NXbrowse</code> to view a data file from the
                    LRMECS spectrometer at IPNS. The following commands are used (see the <code>NXbrowse</code>
                    web pag ): <table>
                        <title>NXbrowse Command Description</title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                            <colspec colwidth="1*"/>
                            <colspec colwidth="3*"/>
                            <thead>
                                <row>
                                    <entry><?dblatex bgcolor="[gray]{0.8}"?>Command</entry>
                                    <entry><?dblatex bgcolor="[gray]{0.8}"?>Description</entry>
                                </row>
                            </thead>
                            <tbody>
                                <row>
                                    <entry>dir</entry>
                                    <entry>List the contents of the current group</entry>
                                </row>
                                <row>
                                    <entry>open Histogram1</entry>
                                    <entry>Open the NeXus group "Histogram1"</entry>
                                </row>
                                <row>
                                    <entry>read title</entry>
                                    <entry>Print the contents of the NeXus data labelled
                                        "title"</entry>
                                </row>
                                <row>
                                    <entry>close</entry>
                                    <entry>Close the current group</entry>
                                </row>
                                <row>
                                    <entry>quit</entry>
                                    <entry>Quit the browser</entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </table><example>
                        <title>Using NXbrowse</title>
                        <programlisting linenumbering="numbered">
%> nxbrowse lrcs3701.nxs

NXBrowse 3.0.0. Copyright (C) 2000 R. Osborn, M. Koennecke, P. Klosowski
    NeXus_version = 1.3.3
    file_name = lrcs3701.nxs
    file_time = 2001-02-11 00:02:35-0600
    user = EAG/RO
NX> dir
  NX Group : Histogram1 (NXentry)
  NX Group : Histogram2 (NXentry)
NX> open Histogram1
NX/Histogram1> dir
  NX Data  : title[44] (NX_CHAR)
  NX Data  : analysis[7] (NX_CHAR)
  NX Data  : start_time[24] (NX_CHAR)
  NX Data  : end_time[24] (NX_CHAR)
  NX Data  : run_number (NX_INT32)
  NX Group : sample (NXsample)
  NX Group : LRMECS (NXinstrument)
  NX Group : monitor1 (NXmonitor)
  NX Group : monitor2 (NXmonitor)
  NX Group : data (NXdata)
NX/Histogram1> read title
  title[44] (NX_CHAR) = MgB2 PDOS 43.37g 8K 120meV E0@240Hz T0@120Hz
NX/Histogram1> open data
NX/Histogram1/data> dir
  NX Data  : title[44] (NX_CHAR)
  NX Data  : data[148,750] (NX_INT32)
  NX Data  : time_of_flight[751] (NX_FLOAT32)
  NX Data  : polar_angle[148] (NX_FLOAT32)
NX/Histogram1/data> read time_of_flight
  time_of_flight[751] (NX_FLOAT32) = [ 1900.000000 1902.000000 1904.000000 ...]
    units = microseconds
    long_name = Time-of-Flight [microseconds]
NX/Histogram1/data> read data
  data[148,750] (NX_INT32) = [ 1 1 0 ...]
    units = counts
    signal = 1 
    long_name = Neutron Counts
    axes = polar_angle:time_of_flight
NX/Histogram1/data> close
NX/Histogram1> close
NX> quit</programlisting>
                    </example></para>
                <para>The source code provides an example of how to write a NeXus reader. The test
                    programs included in the <link xmlns:xlink="http://www.w3.org/1999/xlink"
                        xlink:href="#ApplicationProgramInterfaceSection">NeXus API</link> may also
                    be useful to study. </para>
            </section>
        </section>
        <section xml:id="MailingListsSection">
            <title>NeXus Mailing Lists</title>
            <para>to be written - pull it from the wiki at
                <literal>http://www.nexusformat.org/Mailing_Lists</literal></para>
        </section>
        <section xml:id="WhereToGoFromHereSection">
            <title>Where to go from here?</title>
            <para>The other sections of this document give much more detailed descriptions of the
                NeXus data format. <variablelist>
                    <varlistentry>
                        <term><link xmlns:xlink="http://www.w3.org/1999/xlink"
                                xlink:href="#DesignSection">NeXus Design</link></term>
                        <listitem>
                            <para>This describes NeXus' hierarchical design, and gives more
                                information on how to construct valid groups.</para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <link xmlns:xlink="http://www.w3.org/1999/xlink"
                                xlink:href="#ApplicationProgramInterfaceSection">NeXus
                            API</link></term>
                        <listitem>
                            <para>This describes the NeXus programming interface, with lists of all
                                the subroutines and supported languages</para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <link xmlns:xlink="http://www.w3.org/1999/xlink"
                                xlink:href="#MailingListsSection">NeXus Mailing Lists</link></term>
                        <listitem>
                            <para>NeXus mailing lists</para>
                        </listitem>
                    </varlistentry>
                </variablelist></para>
        </section>
    </section>
    <!-- NEXUS DESIGN SECTION -->
    <section xml:id="DesignSection">
        <title>NeXus Design</title>
        <para>The structure of NeXus files is extremely flexible, allowing the storage both of
            simple data sets, e.g., a single data array and its axes, and also of highly complex
            data, e.g., the simulation results of an entire multi-component instrument. This
            flexibility is achieved through a hierarchical structure, with related data items
            collected together into groups, making NeXus files easy to navigate, even without any
            documentation. NeXus files are self-describing, and should be easy to understand, at
            least by those familiar with the experimental technique.</para>
        <para>The logical design is distinct from the underlying format used to store the NeXus file
            on disk, which are written using the <link xmlns:xlink="http://www.w3.org/1999/xlink"
                xlink:href="#ApplicationProgramInterfaceSection">NeXus Application Program Interface
                (API)</link>. Refer to the API section for more details.</para>
        <section>
            <title>NeXus Objects</title>
            <para>NeXus data files contain two types of elementary object: data items and data
                groups. In addition, metadata required to describe a data item, e.g. its physical
                units,<indexterm><primary>units</primary></indexterm>
                can be attached to the data as data attributes.</para>
            <section>
                <title>Data Items</title>
                <para>Data items contain the essential information stored in a NeXus file. They can
                    be scalar values or multidimensional arrays of a variety of sizes (1-byte,
                    2-byte, 4-byte, 8-byte) and types (integers, floats, characters). The items may
                    store both experimental results (counts, detector angles, etc), and other
                    information associated with the experiment (start and end times, user names,
                    etc). Data items are identified by their names, which must be unique within the
                    group in which they are stored.</para>
            </section>
            <section>
                <title>Data Attributes</title>
                <para>Attributes are extra (meta-)information that are associated with particular
                    data items. They are used to annotate the data, e.g. with physical units
                    <indexterm><primary>units</primary></indexterm>
                    or
                    calibration offsets, and may be scalar numbers or character strings. In
                    addition, NeXus uses attributes to identify plottable data and their axes, etc.
                    Finally, NeXus files themselves have global attributes that identify the NeXus
                    version, file creation time, etc.. Attributes are identified by their names,
                    which must be unique in each data item.</para>
            </section>
            <section>
                <title>Data Groups</title>
                <para>NeXus files consist of data groups, which contain data items and/or other
                    groups to form a hierarchical structure. This hierarchy is designed to make it
                    easy to navigate a NeXus file by storing related data items together. Data
                    groups are identified both by a name, which must be unique within a particular
                    group, and a class. There can be multiple groups with the same class.</para>
            </section>
        </section>
        <section>
            <title>NeXus Classes</title>
            <para>Data groups often describe objects in the experiment (monitors, detectors,
                monochromators, etc.), so that the contents (both data items and/or other data
                groups) comprise the properties of that object. NeXus has defined a set of standard
                objects, or classes, out of which a NeXus file can be constructed. Each data group
                is therefore identified by a name and a class. The group class, which always has
                "NX" as a prefix, defines the type of object and the properties that it can contain,
                whereas the group name defines a unique instance of that class. These classes are
                defined in XML using the NeXus Definition Language (NXDL)
                <indexterm><primary>NXDL</primary></indexterm> format. </para>
            <para>Not all classes define physical objects. Some refer to logical groupings of
                experimental information, such as plottable data, sample environment logs, beam
                profiles, etc.</para>
            <para>The following table shows the hierarchy of a standard NeXus file, and where groups
                of a particular class are located. There can be multiple instances of each class. On
                the other hand, a typical NeXus file will only contain a small subset of the
                possible classes.</para>
            <section>
                <title>NeXus Data</title>
                <para>One NeXus design aim
                    <indexterm>
                        <primary>NeXus</primary>
                        <secondary>design aims</secondary>
                    </indexterm>
                    was to make it possible to separate the
                    measured data in a NeXus file from all the metadata that describe how that
                    measurement was performed. In principle, it should be possible for a plotting
                    utility to identify the plottable data automatically (or to provide a list of
                    choices if there is more than one set of data). In order to distinguish the
                    actual measurements from this metadata, it is stored separately in groups with
                    the class <code>NXdata</code>. These groups encapsulate all the information required to
                    produce a meaningful plot, including any error arrays and axis scales, i.e. the
                    physical values corresponding to the data dimensions.</para>
                <para>The <code>NXdata</code> groups have to be flexible enough to cope with data of arbitrary
                    rank and provide a mechanism for associating axis scales with the appropriate
                    dimension of data. We use data attributes to accomplish this. Here are the main
                    rules that must be followed in constructing an <code>NXdata</code> group. <itemizedlist>
                        <listitem>
                            <para>Each <code>NXdata</code> group will consist of only one data set containing
                                plottable data and their standard deviations.</para>
                        </listitem>
                        <listitem>
                            <para>The data set will be identified by an attribute of "signal" given
                                a value 1. </para>
                        </listitem>
                        <listitem>
                            <para>This data set may be of arbitrary rank. </para>
                        </listitem>
                    </itemizedlist> If available, the standard deviations of the data are to be
                    stored in a data set of the same rank and dimensions, with the name "errors". <itemizedlist>
                        <listitem>
                            <para>For each data dimension, there should be a one-dimensional array
                                of the same length. </para>
                        </listitem>
                        <listitem>
                            <para>These one-dimensional arrays are the "dimension scales" of the
                                data i.e. the values of the independent variables at which the data
                                is measured e.g. scattering angle or energy transfer. </para>
                        </listitem>
                    </itemizedlist></para>
                <para>There are two methods of linking
                    <indexterm><primary>link</primary></indexterm>
                    each data dimension to its respective
                    dimension scale. <orderedlist>
                        <listitem>
                            <para> The first method is to define an attribute of each dimension
                                scale called "axis". It is an integer whose value is the number of
                                the dimension, in order of fastest varying dimension. i.e. if the
                                array being stored is data, with elements data[j][i] in C and
                                data(i,j) in Fortran, where i is the time-of-flight index and j is
                                the polar angle index, the <code>NXdata</code> group would contain : <example>
                                    <title>Old way of denoting axes</title>
                                    <programlisting language="xml" linenumbering="numbered"
                                        ><![CDATA[<NXdata name=" data " > 
         <time_of_flight axis= 1 primary= 1 > 1500.0 1502.0 1504.0 … </time_of_flight> 
         <polar_angle axis= 2 primary= 1 > 15.0 15.6 16.2 … </polar_angle> 
         <data > 5 7 14 … </data> 
</NXdata>]]></programlisting>
                                </example> This attribute must be defined for each dimension scale.
                            </para>
                        </listitem>
                        <listitem>
                            <para>The second method is to define an attribute of the data itself
                                called "axes". It contains the names of each dimensions scale as a
                                comma- or colon-delimited list in the order they appear in C.
                                Optionally, the list can be enclosed in brackets, but should not
                                contain any spaces, e.g. <example>
                                    <title>Preferred way of denoting axes</title>
                                    <programlisting  language="c" linenumbering="numbered"
                                        ><![CDATA[<NXdata name=" data " > 
         <time_of_flight > 1500.0 1502.0 1504.0 … </time_of_flight> 
         <polar_angle > 15.0 15.6 16.2 … </polar_angle> 
         <data axes="polar_angle:time_of_flight" > 5 7 14 … </data> 
</NXdata>]]></programlisting>
                                </example></para>
                        </listitem>
                    </orderedlist> The second method is required when the dimension scale is used in
                    more than one <code>NXdata</code> group in a different context, e.g. it is used as the x-axis
                    in one group and the y-axis in another. </para>
                <para>The first method was historically the first to be used, but the second is now
                    recommended for future applications. However, both will be supported in NeXus
                    utilities that identify dimension scales, e.g. NXUfindaxis. </para>
                <para>There are limited circumstances in which more than one dimension scale for the
                    same data dimension can be included in the same <code>NXdata</code> group. The most common is
                    when they are the three components of an (hkl) scan. In order to handle this
                    case, we have defined another attribute of type integer called "primary" whose
                    value determines the order in which the scale is expected to be chosen for
                    plotting, i.e. 1st choice: primary = 1 2nd choice: primary = 2 etc. If there is
                    more than one scale with the same value of the "axis" attribute, one of them
                    must have the "primary" attribute set to 1. Defining the "primary" attribute for
                    the other scales is optional.</para>
                <para>N.B. The "primary" attribute can only be used with the first method of
                    defining dimension scales discussed above. In addition to the signal data, this
                    group could contain a data set of the same rank and dimensions called "errors"
                    containing the standard deviations of the data.</para>
                <para>It is often (usually) necessary to associate the data and/or axis scales with
                    other metadata stored in other groups, e.g. the NXsample group or components of
                    the NXinstrument group. For example, it may be necessary to perform corrections
                    for the detector efficiency using information stored in the associated
                    <code>NXdetector</code> group. In this case, it is recommended that the relevant arrays are
                    initially stored in those groups, and then linked
                    <indexterm><primary>link</primary></indexterm>
                    to the <code>NXdata</code> group. The API
                    will provide a mechanism for identifying the parent group so that the relevant
                    metadata can be accessed. </para>
                <para>Here is a simple example to illustrate the concept: <example>
                        <title>Abbreviated NeXus file</title>
                        <programlisting linenumbering="numbered" language="xml"><![CDATA[<NXentry name="entry">
    <NXsample name="sample">
        <magnetic_field link="/entry/sample">10.0</magnetic_field>
    </NXsample>
    <NXinstrument name="instrument">
        <NXdetector name="detector">
            <data axes=" time_of_flight:magnetic_field " link="/entry/instrument/detector">5 7 14 etc </data>
            <time_of_flight link="/entry/instrument/detector ">1500.0 1502.0 1504.0 etc </time_of_flight>
        </NXdetector>
    </NXinstrument>
    <NXdata>
        <data axes="time_of_flight:magnetic_field" link="/entry/instrument/detector">{link to values in NXdetector}</data>
        <time_of_flight link="/entry/instrument/detector">{link to values in NXdetector}</time_of_flight>
        <magnetic_field link="/entry/sample">{link to values in NXsample}</magnetic_field>
    </NXdata>
</NXentry>]]></programlisting>
                    </example></para>
                <para>The general principle is that physical quantites are stored in the groups that
                    they refer to (e.g. counts in <code>NXdetector</code>, temperature in NXsample) and these
                    quantities are then linked into NXdata for interpretation. In this example,
                    there are two axis scales, "magnetic_field" and "time_of_flight", which are
                    stored in NXsample and <code>NXdetector</code> groups respectively. A program is able to use
                    the information in the "link" attribute to locate the respective groups. One
                    corollary of this is that there should be one <code>NXdetector</code> group for each NXdata
                    group, e.g. one for each detector bank in a multi-bank instrument.</para>
                <para>The syntax of the "link" attribute requires a bit of explanation. Under HDF4
                    you can only create, what would be called under UNIX, "hard links". Hard links
                    have the characteristics that: <itemizedlist>
                        <listitem>
                            <para>The name of the entity must be the same in both the original and
                                linked groups </para>
                        </listitem>
                        <listitem>
                            <para>The attributes of both the origial entity and the linked one are
                                the same </para>
                        </listitem>
                        <listitem>
                            <para>You cannot distinguish the original entity from the linked
                                one</para>
                        </listitem>
                        <listitem>
                            <para>You cannot follow a link - it is like an inode in a filesystem and
                                just points at the data </para>
                        </listitem>
                    </itemizedlist></para>
                <para>To overcome this and allow us to link from <code>NXdata</code> 
                    to, say, <code>NXsample</code> and to
                    know that the original data belongs to <code>NXsample</code> we write the "link" attribute
                    that contains the path of the original group containing it. All linked entities
                    will share this "link" attribute and thus can use it to locate the original
                    source group. We are effectively using the "link" attribute to simulate
                    "symbolic links". So in the above example both the original "time_of_flight" and
                    the linked one will share a link attribute containing the text
                    "/entry/instrument/detector" because "/entry/instrument/detector/time_of_flight"
                    is the original instance.</para>
            </section>
            <section>
                <title>NeXus Attributes</title>
                <table role="small">
                    <title>Global Attributes</title>
                    <tgroup cols="3" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="1*"/>
                        <colspec colwidth="3*"/>
                        <thead>
                            <row>
                                <entry><?dblatex bgcolor="[gray]{0.8}"?>Name</entry>
                                <entry><?dblatex bgcolor="[gray]{0.8}"?>Type</entry>
                                <entry><?dblatex bgcolor="[gray]{0.8}"?>Description</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>file_name</entry>
                                <entry>NX_CHAR</entry>
                                <entry>File name of original NeXus file to assist in identification
                                    if the external name has been changed</entry>
                            </row>
                            <row>
                                <entry>file_time</entry>
                                <entry>ISO 8601</entry>
                                <entry>Date and time of file creation</entry>
                            </row>
                            <row>
                                <entry>file_update_time</entry>
                                <entry>ISO 8601</entry>
                                <entry>Date and time of last file change at close</entry>
                            </row>
                            <row>
                                <entry>NeXus_version</entry>
                                <entry>NX_CHAR</entry>
                                <entry>Version of NeXus API used in writing the file</entry>
                            </row>
                            <row>
                                <entry>creator</entry>
                                <entry>NX_CHAR</entry>
                                <entry>Facility or program where the file originated</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
                <table>
                    <title>Data Attributes</title>
                    <tgroup cols="3" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="1*"/>
                        <colspec colwidth="3*"/>
                        <thead>
                            <row>
                                <entry><?dblatex bgcolor="[gray]{0.8}"?>Name</entry>
                                <entry><?dblatex bgcolor="[gray]{0.8}"?>Type</entry>
                                <entry><?dblatex bgcolor="[gray]{0.8}"?>Description</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>units</entry>
                                <entry>NX_CHAR</entry>
                                <entry>
                                    <para>
                                        Units of data which must conform to the standard defined by
                                        the Unidata UDunits 
                                        <indexterm><primary>UDunits</primary></indexterm>
                                        utility (in particular, see
                                        <link xmlns:xlink="http://www.w3.org/1999/xlink"
                                            xlink:href="http://www.unidata.ucar.edu/software/udunits/udunits-1/udunits.txt"
                                            ><code>udunits.txt</code></link>)
                                    </para>
                                </entry>
                            </row>
                            <row>
                                <entry>signal</entry>
                                <entry>NX_INT32</entry>
                                <entry>Defines which data set contains the signal to be plotted -
                                    set to 1 for main signal</entry>
                            </row>
                            <row>
                                <entry>axes</entry>
                                <entry>NX_CHAR</entry>
                                <entry>Defines the names of the dimension scales for this data set
                                    as a comma-delimited array, optionally surrounded by brackets
                                    (see a longer discussion in the section on NXdata structure)
                                    i.e. if the array being stored is <code>data</code>, with
                                    elements <code>data[j][i]</code> in C and <code>data(i,j)</code>
                                    in Fortran, with dimension scales <code>time_of_flight[i]</code>
                                    and <code>polar_angle[j]</code>, <code>data</code> would have an
                                    attribute called "axes" with the following value :
                                        <code>[polar_angle,time_of_flight]</code></entry>
                            </row>
                            <row>
                                <entry>axis</entry>
                                <entry>NX_INT32</entry>
                                <entry>As an alternative to using the "axes" attribute, this defines
                                    the rank of the signal data for which this data set is a
                                    dimension scale in order of the fastest varying index (see a
                                    longer discussion in the section on NXdata structure) i.e. if
                                    the array being stored is <code>data</code>, with elements
                                        <code>data[j][i]</code> in C and <code>data(i,j)</code> in
                                    Fortran, "axis" would have the following values: ith dimension
                                    (axis = 1), jth dimension (axis = 2), etc. </entry>
                            </row>
                            <row>
                                <entry>primary</entry>
                                <entry>NX_INT32</entry>
                                <entry>Defines the order of preference for dimension scales which
                                    apply to the same rank of signal data - set to 1 for preferred
                                    dimension scale</entry>
                            </row>
                            <row>
                                <entry>long_name</entry>
                                <entry>NX_CHAR</entry>
                                <entry>Defines title of signal data or axis label of dimension
                                    scale</entry>
                            </row>
                            <row>
                                <entry>calibration_status</entry>
                                <entry>NX_CHAR</entry>
                                <entry>Defines status of data value - set to "Nominal" or
                                    "Measured"</entry>
                            </row>
                            <row>
                                <entry>histogram_offset</entry>
                                <entry>NX_FLOAT32</entry>
                                <entry>Defines the offset from the first data point to its bin
                                    boundary. i.e. left_bin = data[1] - histogram_offset - set to 0
                                    if the data are not histograms. The points themselves should be
                                    set to the bin centers. For reasoning behind this design, see
                                    note on histograms.</entry>
                            </row>
                            <row>
                                <entry>checksum</entry>
                                <entry>NX_INT32</entry>
                                <entry>Sum of data array acting as a check on data integrity</entry>
                            </row>
                            <row>
                                <entry>version</entry>
                                <entry>NX_CHAR</entry>
                                <entry>Version of XML DTD file or schema on which the NeXus file is
                                    based. Should only be used with the "analysis" data item in an
                                    <code>NXentry</code> group.</entry>
                            </row>
                            <row>
                                <entry>URL</entry>
                                <entry>NX_CHAR</entry>
                                <entry>The URL of the XML DTD file or schema on which the NeXus file
                                    is based. Should only be used with the "analysis" data item in
                                    an <code>NXentry</code> group.</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </section>
        </section>
        <section xml:id="NeXus_Coordinate_System">
            <title>NeXus Coordinate System</title>
            <para> Nexus provides two coordinate systems: a <link
                    xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#NXgeometrySection"
                >NXgeometry based system</link> for physical coordinates of beamline components
                and a <link
                    xmlns:xlink="http://www.w3.org/1999/xlink"
                    xlink:href="#Spherical_coordinate_system">
                    <citetitle>polar coordinate based system</citetitle>
                </link> for scattering coordinates. The usage of these
                two systems can be seen by considering a 3He gas tube detector: </para>
            <itemizedlist mark="opencircle">
                <listitem>
                    <para> The <link xmlns:xlink="http://www.w3.org/1999/xlink"
                        xlink:href="#NXgeometry_based_system">NXgeometry system</link> represents true
                        spatial location and would describe a cylinder at a certain distance from
                        the sample that never changes from one run to another </para>
                </listitem>
                <listitem>
                    <para> The 
                        <link
                            xmlns:xlink="http://www.w3.org/1999/xlink"
                            xlink:href="#Spherical_coordinate_system">
                            <citetitle>polar system</citetitle>
                        </link>
                        would describe the scattering, rather than actual,
                        geometry. For example, the <emphasis>distance</emphasis> coordinate would
                        refer to the distance from the sample to an effective measurement point
                        within the gas tube, which would depend on neutron energy; lower energy
                        neutrons would tend to penetrate a smaller distance within the tube, and so
                        have a shorter secondary flight path. </para>
                </listitem>
            </itemizedlist>
            <section xml:id="Spherical_coordinate_system">
                <title>Simple (Spherical Polar) Coordinate System</title>
                <para> In this system the instrument is considered as a set of components through
                    which the incident beam passes. The variable <emphasis role="bold"
                        >distance</emphasis> is assigned to each component and represents the
                    effective beam flight path length between this component and the sample. A sign
                    convention is used where -ve numbers represent components pre-sample and +ve
                    numbers components post-sample. </para>
                <para> For angular information, the quantities <emphasis>polar_angle</emphasis> and
                        <emphasis>azimuthal_angle</emphasis> are used and these quantities
                    correspond exactly to the usual <link xmlns:xlink="http://www.w3.org/1999/xlink"
                        xlink:href="#Spherical_coordinate_system">
                        <citetitle>spherical polar coordinate</citetitle>
                    </link> definitions i.e. the polar_angle is the <emphasis>zenith
                        angle</emphasis> and measured with respect to a <emphasis>z</emphasis> axis
                    and the azimuthal_angle to the <emphasis>x</emphasis> axis in the xy plane. The
                    direction of these local axes may be different for each component:
                        <emphasis>z</emphasis> is the incident beam direction for the <emphasis
                        role="bold">previous</emphasis> component and we then follow <link
                        xmlns:xlink="http://www.w3.org/1999/xlink"
                        xlink:href="http://mcstas.risoe.dk">
                        <citetitle>McStas</citetitle>
                            <indexterm><primary>McStas</primary></indexterm>
                    </link> for <emphasis>x</emphasis> and <emphasis>y</emphasis> i.e. the
                        <emphasis>x</emphasis> axis is perpendicular to the beam in the horizontal
                    plane pointing left as seen from the source, and the <emphasis>y</emphasis> axis
                    points upwards (see diagram below). The <emphasis>z</emphasis> axis thus
                    represents the direction of the beam if it was un-deviated by the previous
                    component, and so the polar_angle and azimuthal_angle for a component indicate
                    how much the beam was bent/scattered by the previous component. </para>
                <para> If we consider an <code>NXdetector</code> element placed directly after an NXsample, the
                        <emphasis>z</emphasis> axis would be in the direction of the beam incident
                    on NXsample. The polar_angle for the <code>NXdetector</code> would be the angle between the
                    scattered beam and this <emphasis>z</emphasis> axis and so correspond to the
                        <emphasis>Bragg angle</emphasis> or <emphasis>two theta</emphasis> even for
                    out-of-plane scattering. The azimuthal_angle would be the angle between the
                    positive x-axis and the scattered beam projected onto the xy-plane - scattering
                    to the left as seen from the source would have azimuthal_angle=0 and scattering
                    to the right azimuthal_angle=pi. The distance would correspond to what is often
                    called the <emphasis>secondary flight path length</emphasis> or
                        <emphasis>L2</emphasis>. </para>
            </section>
            <section xml:id="NXgeometry_based_system">
                <title>NXgeometry based system</title>
                <para> This coordinate system is based more fully on the <link
                        xmlns:xlink="http://www.w3.org/1999/xlink"
                        xlink:href="http://mcstas.risoe.dk">
                        <citetitle>McStas coordinate system</citetitle>
                    <indexterm><primary>McStas</primary></indexterm>
                    </link>. The instrument is given a global, absolute coordinate system where the
                        <emphasis>z</emphasis> axis points in the direction of the incident beam,
                    the <emphasis>x</emphasis> axis is perpendicular to the beam in the horizontal
                    plane pointing left as seen from the source, and the <emphasis>y</emphasis> axis
                    points upwards. Each beamline component also has a local coordinate system,
                    which is defined by the <link xmlns:xlink="http://www.w3.org/1999/xlink"
                        xlink:href="#NXgeometrySection">NXgeometry</link> object. The local
                        <emphasis>z</emphasis> direction for a component is taken as the incident
                    beam direction, with <emphasis>x</emphasis> and <emphasis>y</emphasis> defined
                    as before (<emphasis>i.e.</emphasis> the <emphasis>x</emphasis> axis is
                    perpendicular to the beam in the horizontal plane pointing left as seen from the
                    source, and the <emphasis>y</emphasis> axis points upwards). Information about
                    these coordinate systems and the placement of components is described by the
                        <link xmlns:xlink="http://www.w3.org/1999/xlink"
                        xlink:href="#NXgeometrySection">NXgeometry</link> class via its
                    <code>NXtranslation</code>  and <code>NXorientation</code> members. </para>
                <para>
                    <figure>
                        <title>Definition of translation and orientation geometry</title>
                        <informaltable>
                            <!--<title>Figure AND table?</title>-->
                            <tgroup cols='2'>
                                <tbody>
                                    <row>
                                        <entry>
                                            <mediaobject>
                                                <imageobject>
                                                    <imagedata
                                                        fileref="img/translation-orientation-geometry.jpg"
                                                        width="200pt" scalefit="1"/>
                                                </imageobject>
                                                <caption>
                                                    <para>view from source</para>
                                                </caption>
                                            </mediaobject>
                                        </entry>
                                        <entry>
                                            <mediaobject>
                                                <imageobject>
                                                    <imagedata
                                                        fileref="img/translation-orientation-geometry-2.jpg"
                                                        width="200pt" scalefit="1"/>
                                                </imageobject>
                                                <caption>
                                                    <para>view from detector</para>
                                                </caption>
                                            </mediaobject>
                                        </entry>
                                    </row>
                                </tbody></tgroup>
                        </informaltable>
                        </figure>
                </para>
                <para> When computing a transformation, <code>NXtranslation</code> is applied before
                    <code>NXorientation</code>. All of our axes are right handed and orthogonal. Orientation
                    information is stored as direction cosines. The direction cosines will be
                    between the local coordinate directions and the reference directions (to origin
                    or relative <link xmlns:xlink="http://www.w3.org/1999/xlink"
                        xlink:href="#NXgeometrySection">NXgeometry</link>). Calling the local unit
                    vectors (x',y',z') and the reference unit vectors (x,y,z) the six numbers will
                    be [x' dot x, x' dot y, x' dot z, y' dot x, y' dot y, y' dot z] where "dot" is
                    the scalar dot product (cosine of the angle between the unit vectors). The unit
                    vectors in both the local and reference coordinates are right-handed and
                    orthonormal: with this restriction we only ned to store 6 rather than 9
                    direction cosines as the z' axis can be obtained by the vector cross product of
                    x' and y'.</para>
                <para> The origin of coordinates is arbitrary, but all components in the file must
                    either agree on its absolutelocation or use relative positioning. To allow for
                    this generality, an origin member can be defined in <code>NXentry</code>; its use will be
                    detailed shortly. </para>
                <para> We choose as our absolute the origin the scattering center, which is where a
                    perfectly aligned sample would be. Note that the centre of the sample itself may
                    not always be at this point if the sample is being scanned across the beam. With
                    an origin at the <emphasis>scattering centre</emphasis> the spherical polar
                    coordinate specifications of the detector positions conveniently relates to
                    scattering angles and lengths for direct geometry instruments. </para>
                <para> Individual components of the instrument (e.g. jaws) will have their own set
                    of local axes (x,y,z) which will be fixed to their body in a way defined by
                    their shape. These local axes will probably not coincidewith the global
                    instrument axes and so a set of rotation angles will also need to be stored. For
                    this an <link xmlns:xlink="http://www.w3.org/1999/xlink"
                        xlink:href="#NXgeometrySection">NXgeometry</link> class is defined, along
                    with NXtranslation and NXorientation; the hope is to provide ageneral enough
                    method for relating the location of any object with respect to another object.
                    The mechanism also allows for specifying one position relative to another
                    component: a NeXus file link is made in one instance of an <link
                        xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#NXgeometrySection"
                        >NXgeometry</link> object to another <link
                        xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#NXgeometrySection"
                        >NXgeometry</link> object and a program can then traverse the chain of links
                    to calculate an absolute position. </para>
                <para> NeXus does not need to define absolutely where to place the
                        <emphasis>origin</emphasis>. All components can instead bedeclared with a
                    relative position that ultimately follows a chain back to one object; this will
                    be named<emphasis>origin1</emphasis>, be of class <link
                        xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#NXgeometrySection"
                        >NXgeometry</link> and a member of <code>NXentry</code>. The real space location of this
                    origin is chosen for convenience and should be mentioned in the description
                    attached to <emphasis>origin1</emphasis>. If the origin is taken at the sample,
                    then <emphasis>sample.geometry.distance</emphasis> will always be (0,0,0)
                    relative to <emphasis>origin1</emphasis>; if the origin is taken elsewhere this
                    will not be so, but everything will still work. It may be convenient to define
                    extra origins (similar to <emphasis>arms</emphasis> in <link
                        xmlns:xlink="http://www.w3.org/1999/xlink"
                        xlink:href="http://mcstas.risoe.dk">
                        <citetitle>McStas</citetitle>
                        <indexterm><primary>McStas</primary></indexterm>
                    </link>) at other parts of the instrument. For example,defining one at the
                    centre of a circular array of detectors would allow their positions to be
                    conveniently specified in spherical polar coordinates. Another possibility would
                    be to define the sample relative to<emphasis>origin1</emphasis> and the
                    detectors to <emphasis>origin2</emphasis>; the detectors could then be rotated
                    by a rotation of <emphasis>origin2</emphasis> without modifying <code>NXdetector</code>. </para>
                <para> As well as specifying the component location, it is also necessary to specify
                    the beam direction. Unless otherwise given in an NXbeam member of the component,
                    the incident beam is assumed to be travelling along (0,0,+z) in the coordinate
                    system of the object (or origin) our position was defined relative to. Thus, for
                    a component with absolute positioning the beam will always be in the incident
                    beam direction unless specified by an NXbeam member. </para>
                <para>
                    <emphasis role="bold">Size and Shape</emphasis> (NXshape) </para>
                <para>
<!-- TODO -->
<!-- =========================================================== -->
<warning><para>Need some editing at this point!</para></warning> 
<!-- =========================================================== -->
                    Many instrument components define <emphasis>height</emphasis> and
                        <emphasis>width</emphasis> variables to specify their size when rectangular,
                    a <emphasis>radius</emphasis> variable for when circular etc. Rather than all
                    these different names, an alternative scheme is proposed based on the
                        <emphasis>shape</emphasis> of the object and the local coordinate axes this
                    shape defines. All object would just need to specify a shape
                        (<emphasis>cuboid</emphasis>, <emphasis>cylinder</emphasis> etc.) and a
                    size array. Specifying size[3] would give the dimensions of the object along its
                    local (+-x,+-y,+-z) axes; specifying size[6] would give the extent along
                    (+x,+y,+z,-x,-y,-z) and allow for e.g. asymmetric jaws where the reference point
                    may not be the centre of the rectangle. For example take
                        shape=<emphasis>cylinder</emphasis>: the NXtranslation variable of position
                    would define the location of the reference point for the origin of the local
                    axes: <emphasis>z</emphasis> in the direction of the cylinder axis, 
                    <emphasis>x</emphasis> and <emphasis>y</emphasis> in plane. With no
                    rotation the object would be oriented with its local axes pointing in the
                    direction of axes of the object it was defined relative to, but this can be
                    altered with the NXorientation variable within position. If a size[3]
                    array variable was specified, the reference point must be the centre of the
                    cylinder and the dimension are size[0]=size[1]=radius, size[2]=length/2). If
                    size[6] was specified then the reference point would be elsewhere in the object,
                    with its distance from the cylinder edges along the various axes given
                    byelements of the size[6] array. </para>
            </section>
        </section>
        <section xml:id="NeXus_units">
            <title>NeXus units</title>
            <para>
                Units 
                <indexterm significance="preferred"><primary>units</primary></indexterm>
                must be specified in a format compatrible with
                <link xmlns:xlink="http://www.w3.org/1999/xlink"
                    xlink:href="http://www.unidata.ucar.edu/software/udunits"
                    ><literal>UDunits</literal></link>.
                <indexterm><primary>UDunits</primary></indexterm>
                <footnote><para><literal>UDunits</literal>:
                    <link xmlns:xlink="http://www.w3.org/1999/xlink"
                    xlink:href="http://www.unidata.ucar.edu/software/udunits"
                    ><literal>http://www.unidata.ucar.edu/software/udunits</literal
                    ></link></para></footnote>
            </para>
            <!-- TODO -->
            <note><para>
                These following words are from the documentation of the
                <code>units</code> attribute as defined in <code>nxdl.xsd</code>.
            </para></note>
            <para>
                String describing the engineering units.
                The string should be appropriate for the value
                and should conform to the NeXus rules for units.
                Can conformance be validated or ensured?
            </para>
            <!-- TODO -->
            <note><para>
                These following words are from a proposal on the units and are not authoritative.
            </para></note>
            <para>
                The units of any stored data or metadata should be 
                specified as an attribute, unless they are dimensionless. 
                The following conventions should be adopted:
                <itemizedlist>
                    <listitem>
                        <para>
                            Units of data which must conform to the standard defined by
                            the Unidata UDunits
                            <indexterm><primary>UDunits</primary></indexterm>
                            utility (in particular, see
                            <link xmlns:xlink="http://www.w3.org/1999/xlink"
                                xlink:href="http://www.unidata.ucar.edu/software/udunits/udunits-1/udunits.txt"
                                ><code>udunits.txt</code></link>).
                            <footnote><para><code>udunits.txt</code>:
                                <link xmlns:xlink="http://www.w3.org/1999/xlink"
                                    xlink:href="http://www.unidata.ucar.edu/software/udunits/udunits-1/udunits.txt"
                                ><literal>http://www.unidata.ucar.edu/software/udunits/udunits-1/udunits.txt</literal
                                ></link></para></footnote>
                            ).
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            All units are written in singular form, without abbreviation.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            There will be no spaces in units.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            SI units will be used (e.g., metre, kilogram, second, ampere, 
                            kelvin), using the British English spellings (e.g., "metre", 
                            not "meter"), but "angstrom" and "barn" are also allowed.
                        </para>
                        <!-- TODO -->
                        <warning>
                            <para>
                                Note the spelling of things in UDunits
                                <indexterm><primary>UDunits</primary></indexterm>
                                <emphasis>meters</emphasis> and not 
                                <emphasis>metres</emphasis>?
                                Does NeXus conform completely to UDunits
                                or do we require UDunits + spelling rules?
                                Where do we specify the spelling rules?
                            </para>
                        </warning>
                    </listitem>
                    <listitem>
                        <para>
                            More complex units will be written with mathematical 
                            operators (+,-,/,^) and parentheses, with traditional 
                            operator precedence (e.g.,metre/second)
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Prefixes are allowed, but will be separated from the 
                            unit using the appropriate mathematical operator 
                            (e.g., centi*metre).
                        </para>
                    </listitem>
                </itemizedlist>
            </para>
        </section>
        <section xml:id="NeXus_dimensions">
            <title>NeXus array dimensions</title>
            <para>Here are a couple of examples to get this section started:
                <example>
                    <title>Example of array dimensions.</title>
                    <programlisting linenumbering="numbered" language="xml"
                        ><![CDATA[<field name="data">
  <dimensions size="3"/>
  <!-- other definitions might appear -->
</field><field name="time-of-flight">
  <dimensions size="1">
    <dim index="1" ref="data" refindex="3" incr="1"/>
  </dimensions>
  <!-- other definitions might appear -->
</field>]]></programlisting></example>
                In some programming language, this would make data[i,j,k] and time-of-flight[k+1].
            </para>
        </section>
        <section xml:id="NeXus_data_types">
            <title>NeXus Data Types</title>
            <para>placeholder</para>
        </section>
    </section>
    <!-- NEXUS INSTRUMENTS -->
    <section xml:id="NeXusInstrumentsSection">
        <title>NeXus Instruments</title>
        <para>The NeXus Design page lists the group classes from which a NeXus file is constructed.
            They provide the glossary of items that could, in principle, be stored in a
            standard-conforming NeXus file (other items may be inserted into the file if the author
            wishes, but they won't be part of the standard). If you are going to include a
            particular piece of metadata, consult the class definitions to find out what to call it.
            However, to assist those writing data analysis software, it is useful to provide more
            than a glossary; it is important to define the required contents of NeXus files that
            contain data from particular classes of neutron, x-ray, or muon instrument.</para>
        <para>As part of the NeXus standard, we have identified a number of generic instruments that
            describe an appreciable number of existing instruments around the world. Although not
            identical in every detail, they share enough common characteristics, and more
            importantly, they require sufficiently similar modes of data analysis, to make a
            standard description useful. They are in the process of being defined for the NeXus
            standard. The definitions will be in XML
            <indexterm><primary>XML</primary></indexterm>
            using the NeXus Definition Language (NXDL)
            <indexterm><primary>NXDL</primary></indexterm>
            format.</para>
    </section>
    <!-- FAQ -->
    <section xml:id="FAQSection"><title>Frequently Asked Questions</title>
        <indexterm significance="preferred"><primary>FAQ</primary></indexterm>
        <para>This is a list of
            commonly asked questions concerning the NeXus data format.</para>
        <qandaset>
            <qandaentry>
                <question>
                    <para>How many facilities use NeXus?</para>
                </question>
                <answer>
                    <para>This is continually evolving. It has been used as the instrument format
                        for several years on some or all instruments at a number of facilities
                        including PSI (Switzerland), LLB (France), LANSCE (USA), and APS (USA). 
                        It will be used
                        on all future instrumentation at ISIS (UK), NIST (USA), and ANSTO
                        (Australia). Finally, it has been formally adopted by major facilities under
                        construction, the SNS (USA), JPARC (Japan) and Diamond Light Source
                        (UK).</para>
                </answer>
            </qandaentry>
            <qandaentry>
                <question>
                    <para>NeXus files are only useful for archiving instrumental
                        data, aren't
                        they?</para>
                </question>
                <answer>
                    <para>NeXus files can be used to store both extremely simple data, e.g. a single
                        (x,y) array, and highly complex instrument descriptions. In fact, the
                        original intention of the NeXus data format was to provide a way of
                        interchanging data between facilities and their user communities. However,
                        the power of NeXus hierarchical design has led to its adoption as a standard
                        archiving format by several major facilities, such as ISIS, LANSCE, and the
                        SNS.</para>
                </answer>
            </qandaentry>
            <qandaentry>
                <question>
                    <para>Why aren't <code>NXsample</code> and <code>NXmonitor</code> 
                        groups stored in the <code>NXinstrument</code>
                        group?</para>
                </question>
                <answer>
                    <para>A NeXus file can contain a number of <code>NXentry</code> groups, which may represent
                        different scans in an experiment, or sample and calibration runs, etc. In
                        many cases, though by no means all, the instrument has the same
                        configuration so that it would be possible to save space by storing the
                        <code>NXinstrument</code> group once and using multiple links in the remaining <code>NXentry</code>
                        groups. It is assumed that the sample and monitor information would be more
                        likely to change from run to run, and so should be stored at the top
                        level.</para>
                </answer>
            </qandaentry>
            <qandaentry>
                <question>
                    <para>
                        How do I identify the plottable data?
                        <indexterm><primary>plottable data</primary></indexterm>
                    </para>
                </question>
                <answer>
                    <para>Any program whose aim is to identify plottable data should use the
                        following procedure: <orderedlist>
                            <listitem>
                                <para>Open the first top level NeXus group with class
                                    <code>NXentry</code>.</para>
                            </listitem>
                            <listitem>
                                <para>Open the first NeXus group with class <code>NXdata</code>.</para>
                            </listitem>
                            <listitem>
                                <para>Loop through NeXus data items in this group searching for the
                                    item with attribute "signal" =1. This is the plottable
                                    data.</para>
                            </listitem>
                            <listitem>
                                <para>Check to see if this data item has an attribute called "axes".
                                    If so, the names are defined as a comma-delimited string within
                                    this attribute in the C-order of the data array, and you can
                                    skip the next two steps.</para>
                            </listitem>
                            <listitem>
                                <para>If the "axes" attribute is not defined, search for the
                                    one-dimensional NeXus data items with attribute "primary" =
                                    1.</para>
                            </listitem>
                            <listitem>
                                <para>These are the dimension scales to label the axes of each
                                    dimension of the data.</para>
                            </listitem>
                            <listitem>
                                <para>Link each dimension scale to the respective data dimension by
                                    the "axis" attribute (= 1,2,...,rank of data).</para>
                            </listitem>
                            <listitem>
                                <para>If necessary, close the NXdata group, open the next one and
                                    repeat steps 3 to 6.</para>
                            </listitem>
                            <listitem>
                                <para>If necessary, close the <code>NXentry</code> group, open the next one and
                                    repeat steps 2 to 7. </para>
                            </listitem>
                        </orderedlist> Consult the <link xmlns:xlink="http://www.w3.org/1999/xlink"
                            xlink:href="#ApplicationProgramInterfaceSection">NeXus API</link>
                        section, which describes the routines available to program these operations.
                        In the course of time, generic NeXus browsers will provide this
                        functionality automatically. </para>
                </answer>
            </qandaentry>
            <qandaentry>
                <question>
                    <para>Why are the NeXus classes so complicated? I'll never store all that
                        information</para>
                </question>
                <answer>
                    <para>The NeXus classes are essentially glossaries of terms. If you need to
                        store a piece of information, consult the class definitions to see if it has
                        been defined. If so, use it. However, it is not compulsory to include every
                        item that has been defined if it is not relevant to your experiment. On the
                        other hand, if there is an NeXus definition for your instrument, you are
                        recommended to include all the compulsory items if you want to use standard
                        software to analyze your data.</para>
                </answer>
            </qandaentry>
            <qandaentry>
                <question>
                    <para>I want to produce an application definition. How do I go about it?</para>
                </question>
                <answer>
                    <para>Read the NXDL
                        <indexterm><primary>NXDL</primary></indexterm> Tutorial.</para>
                    <para>If you encounter any problems because the classes are not sufficient to
                        describe your configuration, please contact the NIAC Executive Secretary
                        explaining the problem, and post a suggestion at the relevant class wiki
                        page. The NIAC
                        <indexterm><primary>NIAC</primary></indexterm>
                        is always willing to consider proposals to amend the base
                        classes. The procedures are defined in the NIAC constitution.<footnote>
                            <para>Refer to
                                the most recent version of the NIAC constitution on the NIAC wiki: <link
                                    xlink:href="http://www.nexusformat.org/NIAC"
                                    ><literal>http://www.nexusformat.org/NIAC</literal></link>
                            </para>
                        </footnote></para>
                    <!-- TODO -->
                    <note><para>We might copy the tutorial into this document or at least post 
                        the PDF on the WWW and link to it from here.  The latter is probably 
                        the better option.</para></note>
                </answer>
            </qandaentry>
        </qandaset>
    </section>
</chapter>
