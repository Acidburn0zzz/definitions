<?xml version="1.0" encoding="UTF-8"?>
<?oxygen RNGSchema="http://www.oasis-open.org/docbook/xml/5.0/rng/docbook.rng" type="xml"?>
<!-- # $Id$ -->
<appendix xml:id="FAQ" version="5.0" xmlns="http://docbook.org/ns/docbook"
	xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude">
	<title>Frequently Asked Questions</title>
	<indexterm significance="preferred">
		<primary>FAQ</primary>
	</indexterm>
	<para>This is a list of commonly asked questions concerning the NeXus data format.</para>
	<qandaset>
		<qandaentry>
			<question>
				<para>How many facilities use NeXus?</para>
			</question>
			<answer>
				<para>
					This is not easy to say, not all facilities using NeXus actively
					participate in the committee. Some facilities have reported their
					adoption status on the
					<link xlink:href="http://www.nexusformat.org/Facilities">
						<literal>Facilities Wiki page</literal>
					</link>. Please have a look at this list. Keep in mind that it is not
					complete.
				</para>
			</answer>
		</qandaentry>
		<qandaentry>
			<question>
				<para>NeXus files are binary? This is crazy! How am I supposed to see my data?</para>
			</question>
			<answer>
				<para>
					NeXus files are not per se binary. If you use the XML backend the
					data are stored in a relatively human readable form (see
					<link xlink:href="http://trac.nexusformat.org/definitions/browser/exampledata/code/xml/NXtest.xml.txt" >this example</link>). 
					This backend however is only recommended for very small data sets. With
					the multidimensional data that is routinely recorded on many modern
					instruments it is very difficult anyway to retrieve useful
					information on a VT100 terminal. If you want to try, for example
					<code>nxbrowse</code>
					is a utility provided by the NeXus community that can be very
					helpful to those who want to inspect their files and avoid
					graphical applications. For larger data volumes the binary backends
					used with the appropriate tools are by far superior in terms of
					efficiency and speed and most users happily accept that after having
					worked with supersized "human readable" files for a while.
				</para>
			</answer>
		</qandaentry>
		<qandaentry>
			<question>
				<para>What on disk file format should I choose for my data?</para>
			</question>
			<answer>
				<para> HDF5 is the default file container to use for NeXus data. It
					is the recommended format for all applications. HDF4 is still
					supported as a on disk format for NeXus but for new installations
					preference should be given to HDF5. The XML backend is available
					for special use cases. Choose this option with care considering the
					space and speed implications.</para>
			</answer>
		</qandaentry>
		<qandaentry>
			<question>
				<para>Why are the NeXus classes so complicated? I'll never store all
					that information</para>
			</question>
			<answer>
				<para>The NeXus classes are essentially glossaries of terms. If you
					need to store a piece of information, consult the class definitions
					to see if it has been defined. If so, use it. It is not compulsory
					to include every item that has been defined in the base class if it
					is not relevant to your experiment. On the other hand, a NeXus
					application definition lists a smaller set of compulsory items that
					should allow other researchers or software to analyze your data.
					You should really follow the application definition that
					corresponds to your experiment to take full advantage of NeXus.
				</para>
			</answer>
		</qandaentry>
		<qandaentry>
			<question>
				<para>I don't like NeXus. I seems much faster and simpler to develop
					my own file format. Why should I even consider NeXus?</para>
			</question>
			<answer>
				<para> If you consider using an efficient on disk storage format,
					HDF5 is a better choice than most others. It is fast and efficient
					and well supported in all main stream programming languages and a
					fair share of popular analysis packages. The format is so widely
					used and backed by a big organisation that it will continue to be
					supported for the foreseeable future.</para>
				<para> So if you are going to use HDF5 anyway, why not use the NeXus
					definition to lay out the data in a standardised way? The NeXus
					community spent years trying to get the standard right and
					while you will not agree with every single choice they made in the
					past, you should be able to store the data you have in a quite
					reasonable way. If you do not comply with NeXus chances are most
					people will perceive your format as different but not necessarily
					better than NeXus by any large measure. So it may not be worth the
					effort. Seriously.</para>
				<para>
					If you encounter any problems because the classes are not
					sufficient to describe your configuration, please contact the NIAC
					Executive Secretary explaining the problem, and post a suggestion
					at the relevant class wiki page. Or raise the problem in one of the
					<link xlink:href="http://download.nexusformat.org/doc/html/MailingLists.html">mailing lists</link>. 
					The NIAC
					<indexterm>
						<primary>NIAC</primary>
					</indexterm>
					is always willing to consider new proposals.
				</para>
			</answer>
		</qandaentry>
		<qandaentry>
			<question>
				<para>I want to produce an application definition. How do I go about it?</para>
			</question>
			<answer>
				<para>
					Read the NXDL
					<indexterm>
						<primary>NXDL</primary>
					</indexterm>
					Tutorial in
					<xref linkend="Tutorial-CreatingNxdlSpec" />.
					The procedures for acceptance are defined in the NIAC constitution.
					<footnote>
						<para>
							Refer to the most recent version of the NIAC constitution on the
							NIAC wiki:
							<link xlink:href="http://www.nexusformat.org/NIAC">
								<literal>http://www.nexusformat.org/NIAC</literal>
							</link>
						</para>
					</footnote>
				</para>
			</answer>
		</qandaentry>
		<qandaentry>
			<question>
				<para>
					What is the purpose of
					<code>NXdata</code>?
				</para>
			</question>
			<answer>
				<para>
					<code>NXdata</code>
					contains links to the data stored elsewhere in the
					<code>NXentry</code>. It identifies the default plottable data. This is one of the
					basic motivations (see <xref linkend="SimplePlotting" />)
					<indexterm>
						<primary>NeXus basic motivation</primary>
						<secondary>default plot</secondary>
					</indexterm>
					for the NeXus standard. The choice of the name
					<code>NXdata</code>
					is historic and does not really reflect its function.
				</para>
			</answer>
		</qandaentry>
		<qandaentry>
			<question>
				<para>
					How do I identify the plottable data?
					<indexterm>
						<primary>NeXus basic motivation</primary>
						<secondary>default plot</secondary>
					</indexterm>
				</para>
			</question>
			<answer>
				<!-- TODO check this list! -->
				<para>
					Any program whose aim is to identify plottable data should use the
					following procedure:
					<orderedlist>
						<listitem>
							<para>
								Open the first top level NeXus group with class
								<code>NXentry</code>.
							</para>
						</listitem>
						<listitem>
							<para>
								Open the first NeXus group with class
								<code>NXdata</code>.
							</para>
						</listitem>
						<listitem>
							<para>
								Loop through NeXus fields in this group searching for the item
								with attribute
								<code>signal="1"</code>
								indicating this field has the plottable data.
							</para>
						</listitem>
						<listitem>
							<para>
								Check to see if this field has an attribute called
								<code>axes</code>. If so, the attribute value contains a colon (or comma)
								delimited list (in the C-order of the data array) with the names
								of the dimension scales 
								<indexterm><primary>dimension scale</primary></indexterm>
								associated with the plottable data. And
								then you can skip the next two steps.
							</para>
						</listitem>
						<listitem>
							<para>
								If the
								<code>axes</code>
								attribute is not defined, search for the one-dimensional NeXus
								fields with attribute
								<code>primary="1"</code>.
							</para>
						</listitem>
						<listitem>
							<para> These are the dimension scales
								<indexterm><primary>dimension scale</primary></indexterm>
								to label the axes of each
								dimension of the data.</para>
						</listitem>
						<listitem>
							<para>
								Link each dimension scale
								<indexterm><primary>dimension scale</primary></indexterm>
								to the respective data dimension by
								the
								<code>axis</code>
								attribute (<code>axis="1"</code>,
								<code>axis="2"</code>, ... up to the rank
								<indexterm>
									<primary>rank</primary>
								</indexterm>
								of the data).
							</para>
						</listitem>
						<listitem>
							<para>
								If necessary, close the
								<code>NXdata</code>
								group, open the next one and repeat steps 3 to 6.
							</para>
						</listitem>
						<listitem>
							<para>
								If necessary, close the
								<code>NXentry</code>
								group, open the next one and repeat steps 2 to 7.
							</para>
						</listitem>
					</orderedlist>
					Consult the
					<link xlink:href="#Introduction-NAPI">NeXus API</link>
					section, which describes the routines available to program these
					operations. In the course of time, generic NeXus browsers will
					provide this functionality automatically.
				</para>
			</answer>
		</qandaentry>
		<qandaentry>
			<question>
				<para>How can I specify reasonable axis for my data?</para>
			</question>
			<answer>
				<para> See question on how to find plottable data.</para>
			</answer>
		</qandaentry>
		<qandaentry>
			<question>
				<para>
					Why aren't
					<code>NXsample</code>
					and
					<code>NXmonitor</code>
					groups stored in the
					<code>NXinstrument</code>
					group?
				</para>
			</question>
			<answer>
				<para>
					A NeXus file can contain a number of
					<code>NXentry</code>
					groups, which may represent different scans in an experiment, or
					sample and calibration runs, etc. In many cases, though by no means
					all, the instrument has the same configuration so that it would be
					possible to save space by storing the
					<code>NXinstrument</code>
					group once and using multiple links in the remaining
					<code>NXentry</code>
					groups. It is assumed that the sample and monitor information would
					be more likely to change from run to run, and so should be stored
					at the top level.
				</para>
			</answer>
		</qandaentry>
		<qandaentry>
			<question>
				<para>Specifications are boring. Where can I find some good example
					data files?</para>
			</question>
			<answer>
				<para>
					There are a few checked into the
					<link xlink:href="http://trac.nexusformat.org/definitions/browser/exampledata"> definitions repository</link>. 
					At the moment the selection is quite limited and not very representative.
				</para>
			</answer>
		</qandaentry>
		<qandaentry>
			<question>
				<para>Can I use a NXDL specification to parse a NeXus data file?
				</para>
			</question>
			<answer>
				<para>
					This should be possible as there is nothing in the NeXus
					specifications to prevent this but it is not implemented in NAPI.
					<indexterm>
						<primary>NAPI</primary>
					</indexterm>
					You would need to implement it for yourself. You would be wise to
					consult the algorithms in the Java version of
					<code>NXvalidate</code>
					(see <xref linkend="NXvalidate-java" />) for more details.
				</para>
			</answer>
		</qandaentry>
		<qandaentry>
			<question>
				<para>
					Why do I need to specify the
					<code>NAPItype</code>? My programming language does not need that information and I
					don't care about C and colleagues. Can I leave it out?
				</para>
			</question>
			<answer>
				<para>
					<code>NAPItype</code>
					is necessary. When implementing the NeXus-XML API we strived to
					make this as general as HDF and reasonably efficient for medium
					sized datasets. This is why we store arrays as a large bunch of
					numbers in C-storage order. And we need the
					<code>NAPItype</code>
					to figure out the dimensions of the dataset.
					<indexterm>
						<primary>dimension</primary>
						<secondary>data set</secondary>
					</indexterm>
				</para>
			</answer>
		</qandaentry>
		<qandaentry>
			<question>
				<para>
					Do I have to use the
					<code>NAPI</code>
					subroutines? Can't I read (or write) the NeXus data files with my
					own routines?
				</para>
			</question>
			<answer>
				<para> You are not required to use the NAPI to write valid NeXus
					data files. It is possible to avoid the NAPI to write and read
					valid NeXus data files. But, the programmer who chooses this path
					must have more understanding of how the NeXus HDF or XML data file
					is written. Validation of data files written without the NAPI is
					strongly encouraged.</para>
			</answer>
		</qandaentry>
	</qandaset>
</appendix>
