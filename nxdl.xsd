<?xml version="1.0" encoding="UTF-8"?>
<!--
########### SVN repository information ###################
# $LastChangedDate$
# $LastChangedBy$
# $LastChangedRevision$
# $HeadURL$
########### SVN repository information ###################
-->

<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
	targetNamespace="http://definition.nexusformat.org/nxdl/3.1"
	xmlns:nx="http://definition.nexusformat.org/nxdl/3.1" 
	version="$Id$"
	elementFormDefault="qualified">

	<xs:annotation>
		<xs:documentation>
			# NeXus - Neutron and X-ray Common Data Format
			# 
			# Copyright (C) 2008 NeXus International Advisory Committee (NIAC)
			# 
			# This library is free software; you can redistribute it and/or
			# modify it under the terms of the GNU Lesser General Public
			# License as published by the Free Software Foundation; either
			# version 2 of the License, or (at your option) any later version.
			#
			# This library is distributed in the hope that it will be useful,
			# but WITHOUT ANY WARRANTY; without even the implied warranty of
			# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
			# Lesser General Public License for more details.
			#
			# You should have received a copy of the GNU Lesser General Public
			# License along with this library; if not, write to the Free Software
			# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
			#
			# For further information, see http://www.nexusformat.org
		</xs:documentation>
	</xs:annotation>
	
	<!-- +++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
	
	<xs:include schemaLocation="nxdlTypes.xsd">
		<xs:annotation>
			<xs:documentation>
				Definitions of the basic data types and unit types 
				allowed in NXDL instance files.
			</xs:documentation>
		</xs:annotation>
	</xs:include>
	
	<!-- +++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
	
	<!-- define the document root element -->
	<xs:element name="definition" type="nx:definitionType" />
	
	<!-- +++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->

	<xs:complexType name="definitionType">
		<xs:group ref="nx:groupGroup" minOccurs="0" maxOccurs="unbounded" />
		<xs:attribute name="name" use="required" />
		<xs:attribute name="type" use="required" type="nx:definitionTypeAttr" />
		<xs:attribute name="extends" use="required" />
		<xs:attribute name="svnid" use="optional"/>
	</xs:complexType>
	
	<xs:complexType name="attributeType">
		<xs:annotation>
			<xs:documentation>
				A new element may expect or require some attributes.
			</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="doc" type="nx:docType" minOccurs="0" />
			<xs:element name="enumeration" type="nx:enumerationType"
				minOccurs="0">
				<xs:annotation>
					<xs:documentation>The field can have an enumeration of values</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="name" use="required" />
		<xs:attribute name="type" type="nx:primitiveType" default="NX_CHAR"/>
	</xs:complexType>

	<xs:simpleType name="definitionTypeAttr">
		<xs:restriction base="xs:string">
			<xs:enumeration value="group" />
			<xs:enumeration value="definition" />
		</xs:restriction>
	</xs:simpleType>

	<xs:group name="groupGroup">
		<xs:sequence>
			<xs:element name="doc" type="nx:docType" minOccurs="0"
				maxOccurs="1" />
			<xs:element name="attribute" type="nx:attributeType"
				minOccurs="0" maxOccurs="unbounded" />
			<xs:element name="group" type="nx:groupType" minOccurs="0"
				maxOccurs="unbounded" />
			<xs:element name="field" type="nx:fieldType" minOccurs="0"
				maxOccurs="unbounded" />
		</xs:sequence>
	</xs:group>

	<!-- +++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->

	<xs:complexType name="basicComponent">
		<xs:sequence>
			<xs:element name="doc" type="nx:docType" minOccurs="0" maxOccurs="1" />
		</xs:sequence>
		<xs:attribute name="name" use="required" />
	</xs:complexType>

	<!-- +++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->

	<xs:simpleType name="docType">
		<xs:annotation>
			<xs:documentation>
				This is the basic definition of a new type.
				Components must derive from an existing type 
				and optionally provide documentation.
			</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string"></xs:restriction>
	</xs:simpleType>

	<!-- +++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->

	<xs:complexType name="groupType">
		<xs:annotation>
			<xs:documentation>
				A group element will be used to refer to an existing NX object or locally-defined component.
			</xs:documentation>
		</xs:annotation>
		<xs:group ref="nx:groupGroup" minOccurs="0" maxOccurs="unbounded"/>
		<xs:attribute name="type" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:pattern value="NX.+"></xs:pattern>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute name="minOccurs" use="optional" default="0" type="xs:nonNegativeInteger"/>
		<xs:attribute name="maxOccurs" use="optional"  default="unbounded"/>
		<xs:attribute name="name" use="optional" />
	</xs:complexType>

	<!-- +++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->

	<xs:complexType name="dimsType">
		<!--
Peter Peterson writes:
			Here is a model:
			<field name="data">
			    <dimensions size="3"/>
			    ...
			</field><field name="time-of-flight">
				<dimensions size="1">
					<dim index="1" ref="data" refindex="3" incr="1"/>
				</dimensions>
				...
			</field>
			
			In old terms this would make data[i,j,k] and time-of-flight[k+1]. 
			We need to get to the stage where people
			don't need to read a manual to understand an existing NXDL.

+++++++++++++++++++++++++++++++++++++
then Freddie Akeroyd writes:
I think we have three cases to consider here:
(1) specifying an explicit value for a dimension
(2) specifying a dimension to be the same size as that of an array
already defined elsewhere (optionally +- a value)
(3) specifying a dimension to be the same as a data value defined
elsewhere (e.g. num_scan_points, optionally +- a value)

For (1) how about

<dim index="1" value="3" />

For (2) how about

<field name="data">
<dimensions size="3">
<dim index="1" label="num_time_channels"/>
< !- - dimensions with no constraints or labels do not need to be mentioned - -  >
</dimensions>
</field>
<field name="time_of_flight">
<dimensions size="1">
<dim index="1" ref="num_time_channels" incr="1"/>
</dimensions>
...
</field>

For (3) how about

<field name="num_scan_points" type="NX_INT"
label="nscanpt" />
<field name="data">
<dimensions size="3">
<dim index="1" label="num_time_channels"/>
<dim index="3" ref="nscanpt"/>		    
</dimensions>
</field>

Notes on dim tag:

use 1 for first element in a sequence, +- to indicate sequence direction
(or we could use an attribute instead)
			
<dim index="1">   ! refers to first index (fastest varying)
<dim index="-1">  ! refers to last index (slowest varying)

<dim label="i">   ! we should constrain labels to be unique within the
file and thus could be referred to 
from any location. This would mean that "i"
could not be used everywhere as a label, 
but forcing the use of better names like
"num_time_channels" makes things clearer. In the 
first instance by making label an xs:ID and
ref an xs:IDREF we can enforce "something" in
label="something" to always be unique and "some_ref" in ref="some_ref"
to always point to a 
valid "label" (We may later want to use xs:key
/ xs:keyref to do this if we needed a second
set of unique labels for another purpose)
						
+++++++++++++++++++++++++++++++++++++
then Mark Koennecke writes:
I think the dimensions encoding is tightly integrated with the algorithm we
use to validate them later on. I thought about something like:

<dimensions size="3">
<dim level="0" value="25"/>
<dim level="1" value="np"/>
<dim level="2" path="/entry/blablabla/somefield" dim="0"/>
</dimensions>
The first case is trivial: validate against a number

The general idea is that the dimensions validator would initialise np 
the first place it comes up against it and
checks against the value ever after. We must allow expressions like np+1 
here.

The third syntax is to explicitly address a specific dimension of 
another variable.

		-->
		<xs:annotation>
			<xs:documentation>dimensions of a data element in a NeXus file</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="dim" minOccurs="0" maxOccurs="unbounded">
				<xs:complexType>
					<xs:attribute name="index" type="nx:NX_CHAR">
						<xs:annotation>
							<xs:documentation>Number indicating which axis (subscript) is 
								being described, ranging from 1 up to "size" (rank of the 
								data structure).  For example, given an array A[i,j,k], 
								index="1" would refer to the "i" axis (subscript).</xs:documentation>
						</xs:annotation>
					</xs:attribute>
					<xs:attribute name="value" type="nx:NX_CHAR">
						<xs:annotation>
							<xs:documentation>Length (number of values) of this axis.</xs:documentation>
						</xs:annotation>
					</xs:attribute>
					<xs:attribute name="ref" type="nx:NX_CHAR">
						<xs:annotation>
							<xs:documentation>The dimension specification is the same as 
								that in the "ref" field, specified either by a relative path, 
								such as "polar_angle" or "../Qvec" or absolute path, such as
								"/entry/path/to/follow/to/ref/field".
							</xs:documentation>
						</xs:annotation>
					</xs:attribute>
					<xs:attribute name="refindex" type="nx:NX_CHAR">
						<xs:annotation>
							<xs:documentation>The dimension specification is the same as 
								the "refindex" axis within the "ref" field.
								Requires "ref" attribute to be present.</xs:documentation>
						</xs:annotation>
					</xs:attribute>
					<xs:attribute name="incr" type="nx:NX_CHAR">
						<xs:annotation>
							<xs:documentation>The dimension specification is related to
								the "refindex" axis within the "ref" field by an 
								offset of "incr."  Requires "ref" and "refindex"
								attributes to be present.</xs:documentation>
						</xs:annotation>
					</xs:attribute>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="size" type="nx:NX_CHAR">
			<xs:annotation>
				<xs:documentation>Rank (number of dimensions) of the data structure.  
					For example: a[5] has size="1" while b[8,5,6,4] has size="4".  
					See http://en.wikipedia.org/wiki/Rank_(computer_programming) 
					for more details.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	
	<xs:complexType name="fieldType">
		<xs:complexContent>
			<xs:annotation>
				<xs:documentation>A field element will be used to declare a new element in the component being defined.</xs:documentation>
			</xs:annotation>
			<xs:extension base="nx:basicComponent">
				<xs:sequence>
					<xs:element name="dimensions" type="nx:dimsType"
						minOccurs="0" maxOccurs="1">
						<xs:annotation>
							<xs:documentation>dimensions of a data element in a NeXus file</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="attribute" type="nx:attributeType"
						minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>attributes of field</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="enumeration" type="nx:enumerationType"
						minOccurs="0">
						<xs:annotation>
							<xs:documentation>The field can have an enumeration of values</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
				<xs:attribute name="units" type="nx:anyUnitsAttr">
					<xs:annotation>
						<xs:documentation>
							String describing the engineering units.
							The string should be appropriate for the value
							and should conform to the NeXus rules for units.
							Can conformance be validated or ensured?
						</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="type" type="nx:primitiveType" default="NX_CHAR"/>
				<xs:attribute name="minOccurs" use="optional" default="0">
					<xs:simpleType>
						<xs:restriction base="xs:nonNegativeInteger">
							<xs:enumeration value="0"/>
							<xs:enumeration value="1"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
				<xs:attribute name="maxOccurs" use="optional"  default="1">
					<xs:simpleType>
						<xs:restriction base="xs:nonNegativeInteger">
							<xs:enumeration value="1"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	
	<xs:complexType name="enumerationType">
		<xs:sequence>
			<xs:element name="item" type="nx:enumItemType" minOccurs="1" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	
	<xs:complexType name="enumItemType">
		<xs:sequence>
			<xs:element name="doc" type="nx:docType" minOccurs="0" maxOccurs="1"/>
		</xs:sequence>
		<xs:attribute name="value" use="required"/>
	</xs:complexType>
	
</xs:schema>
