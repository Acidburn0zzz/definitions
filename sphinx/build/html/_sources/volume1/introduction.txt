.. $Id: introduction.rst 869 2011-08-17 23:19:06Z Pete Jemian $

..  _nexus-introduction:

***************************************************************************
NeXus Introduction
***************************************************************************

.. index:: NeXus basic motivation; unified format

In recent years, a community of scientists and computer programmers working 
in neutron and synchrotron facilities around the world came to the 
conclusion that a common data format would fulfill a valuable function in 
the scattering community. As instrumentation becomes more complex and data 
visualization become more challenging, individual scientists, or even 
institutions, have found it difficult to keep up with new developments. A 
common data format makes it easier, both to exchange experimental results 
and to exchange ideas about how to analyze them. It promotes greater 
cooperation in software development and stimulates the design of more 
sophisticated visualization tools. For additional background information see 
:ref:`History`. 

.. sidebar:: quote

	The programmers who produce intermediate files for 
	storing analyzed data should agree on simple interchange rules.

This section is designed to give a brief introduction to NeXus, the data 
format and tools that have been developed in response to these needs. It 
explains what a modern data format such as NeXus is and how to write simple 
programs to read and write NeXus files. 

.. index:: rules
.. ! contents::


.. _WhatIsNeXus:

=====================================================================
What is NeXus?
=====================================================================

The NeXus data format has four components: 

.. index:: NeXus

#.	A set of *design principles*
	to help people understand what is in the data files.
#.	A set of *data storage objects*
	(base classes and application definitions) to allow 
	the development of more portable analysis software.
#.	A set of *subroutines*
	(utilities) to make it easy to read and write NeXus data files.
#.	*Scientific Community*
	to provide the scientific data, advice, and continued involvement
	with the NeXus standard. NeXus provides a forum for the scientific
	community to exchange ideas in data storage.

In addition, NeXus relies on a set of low-level file formats to actually 
store NeXus files on physical media. Each of these components are described 
in more detail in :ref:`Fileformat`. 

.. index:: NAPI 
           
The NeXus Application-Programmer Interface (NAPI), which
provides the set of subroutines for reading and writing NeXus data files,
is described briefly in :ref:`Introduction-NAPI`.
(Further details are provided in the NAPI chapter of Volume II of this
documentation.)

The principles guiding the design and implementation of the NeXus standard
are described in :ref:`Design` .

Base classes and applications,
which comprise the data storage objects used in NeXus data files,
are detailed in the *Class Definitions* chapter of 
Volume II of this documentation.
            
.. With this information, it should be possible to bypass the NAPI and
	read & write NeXus data directly in the low-level file format.

Additionally, a brief list describing the set of NeXus Utilities 
available to browse, validate, translate, and visualise
NeXus data files is provided in :ref:`Utilities`.


.. _Introduction-DesignPrinciples:

A Set of Design Principles
---------------------------------------------------------------------

.. index:: NeXus; Design Principles

NeXus data files contain four types of entity: 
data groups, data fields, attributes, and links. 
See :ref:`Design-Groups` for more details.

1. Data Groups
	*Data groups* are like folders that can contain 
	a number of fields and/or other groups.

.. index:: data objects; groups

2. Data Fields
	*Data fields*
	can be scalar values or multidimensional arrays of a
	variety of sizes (1-byte, 2-byte, 4-byte, 8-byte) and types
	(characters, integers, floats).  In HDF, fields are
	represented as HDF *Scientific Data Sets*
	(also known as SDS).

.. index:: data objects; fields
.. index:: HDF; Scientific Data Sets
.. see also - data objects, fields
.. index:: Scientific Data Sets
.. see also - data objects, fields
.. index:SDS
.. see also - data objects, fields

3. Data Attributes
	Extra information required to
	describe a particular group or field, 
	such as the data units,
	can be stored as a data attribute.

.. index:: units
.. index:: attributes; data
.. index:: data objects; attributes

4. Links
	Links are used to reference the plottable data
	from ``NXdata`` when the data is provided in 
	other groups such as ``NXmonitor`` or ``NXdetector``.

.. index:: NeXus basic motivation; default plot
.. index:: link

In fact, a NeXus file can be viewed as a computer file system. Just as files
are stored in folders (or subdirectories) to make them easy to locate, so NeXus
fields are stored in groups. The group hierarchy
is designed to make it easy to navigate a NeXus file.

.. index:: hierarchy


.. _Introduction-ExampleFile:

Example of a NeXus File
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The following diagram shows an example of a NeXus data file 
represented as a tree structure.

.. index:: hierarchy; example NeXus data file

.. figure:: ../../../manual/img/Hierarchy.png
	:width: 300 pt
	:alt: example NeXus data file hierarchy

	Example of a NeXus data file

Note that each field is identified by a name, such as ``counts``,
but each group is identified both by a name and, after a colon as a 
delimiter, the class type, e.g., ``monitor:NXmonitor``). 
The class types, which all begin with ``NX``, 
define the sort of fields that the group should contain, in this
case, counts from a beamline monitor. The hierarchical design, with data
items nested in groups, makes it easy to identify information if you are
browsing through a file. 


.. _Introduction-ImportantClasses:

Important Classes
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Here are some of the important classes found in nearly all NeXus files. A
complete list can be found in the NeXus Design section (:ref:`Design`).

.. note:: ``NXentry`` and ``NXdata``
	are the only two classes **required** in a valid NeXus data file.

.. index:: classes; base class: NXentry

``NXentry``
	(**Required:**)
	The top level of any NeXus file contains one or more
	groups with the class ``NXentry``.
	These contain all the data that is required to
	describe an experimental run or scan. Each
	``NXentry`` typically contains a number of
	groups describing sample information (class
	``NXsample``), instrument details (class
	``NXinstrument``), and monitor counts (class
	``NXmonitor``).  

.. index:: classes; base class: NXdata
.. index:: NeXus basic motivation; default plot

``NXdata``
	(**Required:**)
	Each ``NXentry`` group contains one or more
	groups with class ``NXdata``. 
	These groups contain the experimental results
	in a self-contained way, i.e., it should be possible to
	generate a sensible plot of the data
	from the information
	contained in each ``NXdata`` group. That means it
	should contain the axis labels and titles as well as the
	data.

.. index:: classes; base class: NXsample

``NXsample``
	A ``NXentry`` group will often contain a group
	with class ``NXsample``. 
	This group contains information pertaining to
	the sample, such as its chemical composition, mass, and
	environment variables (temperature, pressure, magnetic
	field, etc.).

.. index:: classes; base class: NXinstrument

``NXinstrument``
	There might also be a group with class
	``NXinstrument``.
	This is designed to encapsulate all the
	instrumental information that might be relevant to a
	measurement, such as flight paths, collimations, chopper
	frequencies, etc.

.. figure:: ../../../manual/img/NXinstrument.png
	:width: 200 pt
	:alt: example NeXus data file hierarchy

	NXinstrument excerpt

Since an instrument can comprise several beamline components each
defined by several parameters, they are each specified by a separate group.
This hides the complexity from generic file browsers, but makes the
information available in an intuitively obvious way if it is required.


.. _Introduction-SimpleExample:

Simple Data File Example
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

NeXus data files do not need to be complicated. 
In fact, the following diagram shows an extremely simple NeXus file
(in fact, the simple example shows the minimum information necessary
for a NeXus data file) that could be used to transfer
data between programs. (Later in this section, we show how to write and 
read this simple example.)

.. figure:: ../../../manual/img/Simple.png
	:width: 250 pt
	:alt: Simple Data File Example figure

	Simple Data File Example
 
This illustrates the fact that the structure of NeXus files is
extremely flexible. It can accommodate very complex instrumental
information, if required, but it can also be used to store very simple data
sets.  In the next example, a NeXus data file is shown as XML:

.. _ex.verysimple.xml:

``verysimple.xml``: A very simple NeXus Data file (in XML)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: xml
	:linenos: 

	<?xml version="1.0" encoding="UTF-8"?>
	  <NXroot NeXus_version="4.3.0" XML_version="mxml"
		file_name="verysimple.xml"
		xmlns="http://definition.nexusformat.org/schema/3.1"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="http://definition.nexusformat.org/schema/3.1 
		                    http://definition.nexusformat.org/schema/3.1/BASE.xsd"
		file_time="2010-11-12T12:40:17-06:00">
		<NXentry name="entry">
		  <NXdata name="data">
			<counts 
			  NAPItype="NX_INT64[15]" 
			  long_name="photodiode counts" 
			  signal="NX_INT32:1" 
			  axes="two_theta">
				   1193       4474 
				  53220     274310 
				 515430     827880 
				1227100    1434640 
				1330280    1037070 
				 598720     316460 
				  56677       1000 
				   1000 
			</counts>
			<two_theta 
			  NAPItype="NX_FLOAT64[15]" 
			  units="degrees" 
			  long_name="two_theta (degrees)">
				18.90940         18.90960         18.90980         18.91000 
				18.91020         18.91040         18.91060         18.91080 
				18.91100         18.91120         18.91140         18.91160 
				18.91180         18.91200         18.91220 
			</two_theta>
		  </NXdata>
		</NXentry>
	  </NXroot>

.. index:: example; very simple

NeXus files are easy to create.  This example NeXus file was created using
a short Python program and NeXpy:

.. _ex.verysimple.py:

``verysimple.py``: Using NeXpy to write a very simple NeXus Data file (in HDF5)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.. index:: example; very simple
.. literalinclude:: ../../../manual/examples/verysimple.py
	:linenos: 
	:tab-width: 4

.. _Introduction-DataStorageObjects:

A Set of Data Storage Objects
---------------------------------------------------------------------
.. index:: instrument definitions 

If the design principles are followed, 
it will be easy for anyone browsing a
NeXus file to understand what it contains, 
without any prior information.
However, if you are writing specialized 
visualization or analysis software, you will need to
know precisely what specific information is contained 
in advance. For that reason, NeXus
provides a way of defining the format for 
particular instrument types,
such as time-of-flight small angle neutron scattering. This requires
some agreement by the relevant communities, but enables the development of
much more portable software.

The set of data storage objects is divided into three parts:
base classes, application definitions, and contributed definitions.
The base classes represent a set of components that define 
the dictionary of all possible terms to be used with that component.
The application definitions specify the minimum required information to satisfy
a particular scientific or data analysis software interest.
The contributed definitions have been submitted by the scientific community
for incubation before they are adopted by the NIAC or for availability
to the community.

These instrument definitions are formalized as XML files, using NXDL,
(as described in the NXDL chapter in Volume II of this documentation)
to specify the names of data fields, and other NeXus data objects. 
The following is an example of such a file for
the simple NeXus file shown above. 

.. _ex.verysimple.nxdl.xml:

``verysimple.nxdl.xml``: A very simple NeXus Definition Language (NXDL) file
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: xml
	:linenos: 

	<?xml version="1.0" ?> 
	<definition 
	  xmlns="http://definition.nexusformat.org/nxdl/3.1" 
	  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	  xsi:schemaLocation="http://definition.nexusformat.org/nxdl/3.1 ../nxdl.xsd"
	  category="base"
	  name="verysimple"
	  version="1.0"
	  svnid="$Id: introduction.rst 869 2011-08-17 23:19:06Z Pete Jemian $"
	  type="group" extends="NXobject">
	  
	  <doc>
		A very simple NeXus NXDL file
	  </doc>
	  <group type="NXentry">
		<group type="NXdata">
		  <field name="counts" type="NX_INT"  units="NX_UNITLESS">
			<doc>counts recorded by detector</doc>
		  </field>
		  <field name="two_theta" type="NX_FLOAT" units="NX_ANGLE">
			<doc>rotation angle of detector arm</doc>
		  </field>
		</group>
	  </group>
	</definition>

.. index:: example; very simple

.. (See *<link xlink:href="#Impatient">A complete example of writing and 
	reading a NeXus data file</link>* for an example to write and read data
	using the structure of :ref:`ex.verysimple.nxdl.xml`.)

This chapter has several examples of writing and reading NeXus data files.
If you want to define the format of a particular type of NeXus file
for your own use, e.g. as the standard output from a program, you are encouraged
to *publish* the format using this XML format. 
An example of how to do this is shown in the section titled
Creating a NXDL Specification (:ref:`NXDL_Tutorial-CreatingNxdlSpec`).


.. _Introduction-SetOfSubroutines:

A Set of Subroutines
---------------------------------------------------------------------

NeXus data files are high-level so the user only needs to 
know how the data are referenced in the file but does not 
need to be concerned where the data are stored in the file.  Thus, the data
are most easily accessed using a subroutine library tuned to the
specifics of the data format.

In the past, a data format was defined by a document 
describing the precise location of every item in the data file, 
either as row and column numbers in an ASCII file, or as record 
and byte numbers in a binary file. It is the job of the subroutine 
library to retrieve the data.  This subroutine library is commonly 
called an application-programmer interface or API.

For example, in NeXus, a program to read in the wavelength of an experiment
would contain lines similar to the following:

.. _ex.simple.c:

Simple example of reading data using the NeXus API
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. index:: example; simple
.. code-block:: c
	:linenos: 

	NXopendata (fileID, "wavelength");
	NXgetdata (fileID, lambda);
	NXclosedata (fileID);

In this example, the program requests the value of the data that has
the label ``wavelength``, storing the result in the variable lambda.
``fileID`` is a file identifier that is provided by NeXus when the
file is opened. 

We shall provide a more complete example when we have 
discussed the contents of the NeXus files.

.. .. include:: intro-lowlevel.inc
.. .. include:: motivations.inc

.. _Scientific_Community:

NeXus Scientific Community 
-------------------------------------------------------

.. note:: **TODO:**
    Show how these work together.
	
	* NIAC
	* NeXus Wiki
	* ...

.. _Introduction-NAPI:

=====================================================================
NAPI: The NeXus Application Programming Interface
=====================================================================

.. index:: NAPI

The NeXus API consists of routines to read and 
write NeXus data files and
was written to shield (and hide) the complexity
of the HDF API from scientific programmers and 
users of the NeXus Data Standard.

Further documentation of the NeXus Application Programming Interface
(NAPI) for bindings to specific programming language can be obtained
from the NeXus development site. [#]_

For a more detailed description of the internal workings of NAPI
that is maintained (mostly) concurrent with code revisions,
see the NAPI chapter in Volume II of this documentation and also 
`NeXusIntern.pdf <http://svn.nexusformat.org/code/trunk/doc/api/NeXusIntern.pdf>`_
in the NeXus code repository. [#]_
Likely this is only interesting for experienced
programmers who wish to hack the NAPI.

.. [#] `http://download.nexusformat.org  <http://download.nexusformat.org>`_
.. [#] `http://svn.nexusformat.org/code/trunk/doc/api/NeXusIntern.pdf  <http://svn.nexusformat.org/code/trunk/doc/api/NeXusIntern.pdf>`_


.. _Introduction-HowToWrite:

How do I write a NeXus file?
---------------------------------------------------------------------------------

.. index:: file; write
.. index:: NAPI

The NeXus Application Program Interface (API) 
provides a set of subroutines that make it easy to read and write
NeXus files. These subroutines are available in C, Fortran 77, Fortran 90, Java,
Python, C++,
and IDL. Access from other languages, such as Python, is anticipated in the near
future. It is also possible to read NeXus HDF files in a number of data analysis
tools, such as LAMP, ISAW, IgorPro, and Open GENIE.  NeXus XML files can be read 
by any program or library that supports XML.

The API uses a very simple *state*
model to navigate through a NeXus file.
When you open a file, the API provides a file *handle*, 
which then stores the
current location, i.e. which group and/or field is currently open. Read and
write operations then act on the currently open entity. 
Following the simple example of :ref:`fig.simple-example`,
we walk through some parts of a typical NeXus program written in C.

.. TODO: Where is :ref:`fig.simple-example`?

.. _ex.simple.write:

Writing a simple NeXus file
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. index:: example; simple
.. code-block:: text
	:linenos: 

	#include "napi.h"

	 int main()
	 {
		NXhandle fileID;
		NXopen ('NXfile.nxs', NXACC_CREATE, &fileID);
		  NXmakegroup (fileID, "Scan", "NXentry");
		  NXopengroup (fileID, "Scan", "NXentry");
			NXmakegroup (fileID, "data", "NXdata");
			NXopengroup (fileID, "data", "NXdata");
			/* somehow, we already have arrays tth and counts, each length n*/
			  NXmakedata (fileID, "two_theta", NX_FLOAT32, 1, &n);
			  NXopendata (fileID, "two_theta");
				NXputdata (fileID, tth);
				NXputattr (fileID, "units", "degrees", 7, NX_CHAR);
			  NXclosedata (fileID);  /* two_theta */, NX_INT32, 1, &n);
			  NXopendata (fileID, "counts");
				NXputdata (fileID, counts);
			  NXclosedata (fileID);  /* counts */
			NXclosegroup (fileID);  /* data */
		  NXclosegroup (fileID);  /* Scan */
		NXclose (&fileID);
		return;
	}

[line 6]
	Open the file ``NXfile.nxs`` with 
	*create* 
	access (implying write access).
	NAPI returns a file identifier of type ``NXhandle``.

[line 7]
	Next, we create an
	``NXentry`` group to contain the scan using 
	``NXmakegroup()`` and then
	open it for access using ``NXopengroup()``.

[line 9]
	The plottable data
	is contained within an ``NXdata`` group, which must
	also be created and opened.

.. index:: NeXus basic motivation; default plot

[line 12]
	To create a field, call ``NXmakedata()``, specifying the
	data name, type (``NX_FLOAT32``), rank
	(in this case, 
	``1``), and length of the array
	(``n``). Then, it can be opened for writing.

.. index:: rank

[line 14]
	Write the data using ``NXputdata()``. 

[line 15]
	With the field still open, we can also add some data attributes,
	such as the data units,
	which are specified as a character string (type ``NX_CHAR``)
	that is 7 bytes long.

.. index:: attributes; data
.. index:: units

[line 16]
	Then we close the field before opening another. 
	In fact, the API will do this automatically if you 
	attempt to open another field, but it is
	better style to close it yourself. 

[line 17]
	The remaining fields in this group are added in a similar
	fashion. Note that the indentation whenever a new field or 
	group are opened is just intended to make the structure of
	the NeXus file more transparent.

[line 20]
	Finally, close the groups (``NXdata`` and 
	``NXentry``) before closing the file itself. 


.. _Introduction-HowToRead:

How do I read a NeXus file?
---------------------------------------------------------------------------------

.. index:: file; read
.. index:: NAPI
.. index:: rank

Reading a NeXus file is almost identical to writing one. Obviously, it is not
necessary to call ``NXmakedata()`` 
since the item already exists, but it
is necessary to call one of the query routines to find out the rank
and length of the data before allocating an array to store it.

Here is part of a program to read the two-theta array from the file
created by :ref:`ex.simple.write` above.

.. _ex.simple.read:

Reading a simple NeXus file
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: text
	:linenos: 

	 NXopen ('NXfile.nxs', NXACC_READ, &fileID);
	   NXopengroup (fileID, "Scan", "NXentry");
		 NXopengroup (fileID, "data", "NXdata");
		   NXopendata (fileID, "two_theta");
			 NXgetinfo (fileID, &rank, dims, &datatype);
			 NXmalloc ((void **) &tth, rank, dims, datatype);
			 NXgetdata (fileID, tth);
		   NXclosedata (fileID);
		 NXclosegroup (fileID);
	   NXclosegroup (fileID);
	 NXclose (fileID);

.. index:: example; simple


.. _Introduction-HowToBrowse:

How do I browse a NeXus file?
---------------------------------------------------------------------------------

.. index:: file; browse
.. index:: utility; nxbrowse

NeXus files can also be viewed by a command-line browser,
``NXbrowse``, which is included with the NeXus API (:ref:`Introduction-NAPI`).
The following is an example session of using ``nxbrowse``
to view a data
file from the LRMECS spectrometer at IPNS. The following commands 
are used in :ref:`ex.NXbrowse.lrmecs` in this session (see
the ``nxbrowse`` web page):

.. _ex.NXbrowse.lrmecs:

Using ``NXbrowse``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: text
	:linenos: 

	%> nxbrowse lrcs3701.nxs

	NXBrowse 3.0.0. Copyright (C) 2000 R. Osborn, M. Koennecke, P. Klosowski
		NeXus_version = 1.3.3
		file_name = lrcs3701.nxs
		file_time = 2001-02-11 00:02:35-0600
		user = EAG/RO
	NX> dir
	  NX Group : Histogram1 (NXentry)
	  NX Group : Histogram2 (NXentry)
	NX> open Histogram1
	NX/Histogram1> dir
	  NX Data  : title[44] (NX_CHAR)
	  NX Data  : analysis[7] (NX_CHAR)
	  NX Data  : start_time[24] (NX_CHAR)
	  NX Data  : end_time[24] (NX_CHAR)
	  NX Data  : run_number (NX_INT32)
	  NX Group : sample (NXsample)
	  NX Group : LRMECS (NXinstrument)
	  NX Group : monitor1 (NXmonitor)
	  NX Group : monitor2 (NXmonitor)
	  NX Group : data (NXdata)
	NX/Histogram1> read title
	  title[44] (NX_CHAR) = MgB2 PDOS 43.37g 8K 120meV E0@240Hz T0@120Hz
	NX/Histogram1> open data
	NX/Histogram1/data> dir
	  NX Data  : title[44] (NX_CHAR)
	  NX Data  : data[148,750] (NX_INT32)
	  NX Data  : time_of_flight[751] (NX_FLOAT32)
	  NX Data  : polar_angle[148] (NX_FLOAT32)
	NX/Histogram1/data> read time_of_flight
	  time_of_flight[751] (NX_FLOAT32) = [ 1900.000000 1902.000000 1904.000000 ...]
		units = microseconds
		long_name = Time-of-Flight [microseconds]
	NX/Histogram1/data> read data
	  data[148,750] (NX_INT32) = [ 1 1 0 ...]
		units = counts
		signal = 1 
		long_name = Neutron Counts
		axes = polar_angle:time_of_flight
	NX/Histogram1/data> close
	NX/Histogram1> close
	NX> quit

.. index:: example; simple

[line 1]
	Start ``NXbrowse`` from the UNIX command 
	line and open file ``lrcs3701.nxs`` from 
	IPNS/LRMECS.
[line 8] 
	List the contents of the current group.
[line 11]
	Open the NeXus group ``Histogram1``.
[line 23]
	Print the contents of the NeXus data labelled ``title``.
[line 41] 
	Close the current group.
[line 43] 
	Quits ``NXbrowse``.

The source code of ``NXbrowse`` [#]_
provides an example of how to write a NeXus reader. 
The test programs included in the NeXus API (:ref:`Introduction-NAPI`)
may also be useful to study.

.. [#] `https://svn.nexusformat.org/code/trunk/applications/NXbrowse/NXbrowse.c  <https://svn.nexusformat.org/code/trunk/applications/NXbrowse/NXbrowse.c>`_
