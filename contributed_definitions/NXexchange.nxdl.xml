<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="nxdlformat.xsl" ?>
<!--
  NXexchange
    A simple common exchange format for spectra and images
		written in the NeXus Definition Language
		as a NeXus "application definition"
		based on a proposal from Chris Jacobsen at the APS.
-->
<definition   name="NXexchange" 
  extends="NXobject" 
  type="group" 
  category="contributed"
  version="0.3b"
  xmlns="http://definition.nexusformat.org/nxdl/3.1"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:db="http://docbook.org/ns/docbook"
  xsi:schemaLocation="http://definition.nexusformat.org/nxdl/3.1 ../nxdl.xsd"
  svnid="$Id$">
  
  <symbols>
    <doc>These symbols will be used below to coordinate datasets with the same shape.</doc>
    <symbol name="axesRank"><doc>number of axes used to collect the data</doc></symbol>
    <symbol name="frameRank"><doc>rank of each data frame</doc></symbol>
    <symbol name="darkRank"><doc>rank of dark_data acquisition<!-- FIXME --></doc></symbol>
    <symbol name="whiteRank"><doc>rank of white_data acquisition<!-- FIXME --></doc></symbol>
  </symbols>

    <doc>
      +++ Under development and subject to unannounced changes +++

      Minimal format for exchange of images and spectra.
      Intended to be used as NXsubentry, as a child of a NXentry group.
      
      "Our goal is to provide a group within a HDF5 file that can be used 
      for simple exchange of images, spectra, and so on with an absolute 
      minimum of required definition. All exchanged items should be in 
      a HDF5 group /exchange or, if multiple datasets are to be shared, 
      /exchange1, /exchange2, and so on.  At a minimum, programs can 
      simply look for this group and ignore all others.  This means 
      that any beamline or instrument can store its own metadata without 
      interfering with the ability for wide exchange."
      
      What differentiates this from an NXdata group is the addition of 
      other fields and groups to provide optional metadata within this 
      /exchange group.  As typical for HDF5 files, these can also be 
      hard-linked to other positions in the HDF5 tree.
    </doc>

  <group name="exchange" type="NXsubentry">
    
    <field name="definition">
      <doc>Official NeXus NXDL schema to which this file conforms</doc>

      <attribute name="version">
        <doc>NXDL version number</doc>
        <enumeration>
          <item value="0.3b"/><!-- keep this string in sync with version attribute above -->
        </enumeration>
      </attribute>

      <enumeration>
        <item value="NXexchange"/><!-- this is the NXexchange specification -->
      </enumeration>
    </field>
    
    <!-- default type is NX_CHAR (any string representation) -->

    <field name="data" type="NX_NUMBER">
      <doc>
         An array that holds the spectrum, spectra, image, image set, ...

         Note that because HDF5 records the type of the data
         (float, 16 bit integer, etc.)  and the rank and dimensions, 
         the reading program should be able to handle reading any
          of these data types. 
          
        For multi-dimensional arrays, the ordering scheme is specified by NeXus
        (TODO  good place to re-describe the NeXus array index ordering scheme is here).
      </doc>
      <dimensions rank="frameRank + axesRank">
        <doc>
          Datasets might be simple 1-D or 2-D scans or images or might be a composite
          of frames, each sample at one or more independent dimensions.  Consider the 
          example of a 1-D position scan of MCA spectra.  Here, <db:code>frameRank</db:code>
          would be <db:code>1</db:code> and <db:code>axesRank</db:code> would also be 
          <db:code>1</db:code>.  Another example might be a 2-D position scan of a 1-D 
          dectector where <db:code>frameRank = 1</db:code> and 
          <db:code>axesRank = 2</db:code>.
        </doc>
      </dimensions>
      <attribute name="complex_index" type="NX_INT">
        <doc>
          [TODO This needs more work.  HDF5 and also NeXus do not define how complex numbers are stored.]

          This attempts to work with the suggestion from THG.
          Flags the data as complex {real,imaginary} pairs. 
          If absent, negative or greater than the rank of the data, 
          it is assumed that the array is pure real. For an example 640x480 complex array, 
          one might have complex_index=0 and the data array has HDF5 stored dimensions of
          (2,640,480) which has a rank of 3.
        </doc>
      </attribute>
      <attribute name="data_type">
        <doc>
          Short name (one word, no whitespace) for the type of data collected.  
          For consistency, 
          users are encouraged to choose names from this list:
          transmission, optical_density, fluorescence, energy_loss,
          photoelectrons, diffraction_intensity, refractive_index, 
          coherent_diffraction_imaging.
          Keep in mind these notes about some of the types:
          transmission
            (units are dimensionless), 
          optical_density 
            (absorbance with 1 meaning the transmittance was reduced by e-1),
          refractive_index 
            (in coherent diffraction imaging, the reconstructed image voxel 
            values might be listed as complex values of transmission or 
            of refractive_index)
          coherent_diffraction_imaging 
            (In coherent diffraction imaging, the reconstructed 
            image voxel values might be listed as complex values 
            of transmission or of refractive_index.)
        </doc>
      </attribute>
      <attribute name="axes">
        <doc>
          Colon-delimited list of the positioner names, 
          such as:  <db:code>axes="ttheta:energy"</db:code>, used to describe 
          each dimension of the <db:emphasis>data</db:emphasis>.
          Each positioner in the <db:code>axes</db:code> list will have a 
          field (HDF5 "dataset") next to the plottable dataset and the length 
          of that vector must correspond to the length of the 
          corresponding axis of the plottable dataset.  For example:
          data is an array of size <db:code>int16[500,200,1000]</db:code> and has 
          an attribute <db:code>axes="energy:ttheta:time"</db:code>.  There will be 
          three additional datasets in this group defined as
          <db:code>energy float64[500]</db:code>, 
          <db:code>ttheta float64[200]</db:code>, and 
          <db:code>time float64[1000]</db:code>.
          The number of axes in this list defines the symbol <db:code>axesRank</db:code>.
        </doc>
      </attribute>
    </field>

    <!-- +++++++++++++++ optional items +++++++++++++++++++++++++++ -->
    
    <field name="dark_data" type="NX_NUMBER">
      <doc>
        (optional) data set with no beam.  
        Must be same dimensions as images stored in "data".
      </doc>
      <dimensions rank="frameRank + darkRank">
        <doc>
          See <db:code>data</db:code> above.  It may be desired to collect 
          <db:emphasis>dark</db:emphasis> data on a different schedule
          than the primary data.  Each <db:emphasis>dark</db:emphasis> data
          frame must have the same shape as the frames in <db:code>data</db:code>.
          <!-- how to further describe these variable dimensions in NeXus? -->
        </doc>
      </dimensions>
    </field>
    
    <field name="white_data" type="NX_NUMBER">
      <doc>
        (optional) data set with illumination.  
        Must be same dimensions as images stored in "data".
      </doc>
      <dimensions rank="frameRank + whiteRank">
        <doc>
          See <db:code>data</db:code> above.  It may be desired to collect 
          <db:emphasis>white</db:emphasis> data on a different schedule
          than the primary data.  Each <db:emphasis>white</db:emphasis> data
          frame must have the same shape as the frames in <db:code>data</db:code>.
          <!-- how to further describe these variable dimensions in NeXus? -->
        </doc>
      </dimensions>
    </field>
  
    <field name="collection_time" type="NX_DATE_TIME">
      <doc>
        Date and time of data was collected (ISO 8601 format).  
        If there are more than one time to be reported, use an NXnote group.
      </doc>
    </field>
  
    <group type="NXsample">
      <doc>
        Description of each sample.  
        One NXsample for each.
      </doc>
    </group>  
    
    <group type="NXinstrument">
      <doc>
        Description of each instrument.  
        One NXinstrument for each.
      </doc>
    </group>
    
    <group type="NXuser">
      <doc>
        Description of each experimenter.  
        One NXuser for each person or group (use judgment).
      </doc>
    </group>
    
    <group type="NXnote" name="original_data">
      <doc>
        Document the file name(s) and time at which the original data was recorded.
        Record the date and time the data was acquired in the "date" field of this NXnote.
        Other fields include file_name, author, type (for MIME type), and a "data" field 
        that can be used to store a thumbnail or anything else.
      </doc>
    </group>
    
    <group type="NXnote">
      <doc>
        Record of any other item regarding the specimen or experiment.
      </doc>
    </group>
    
    <group type="NXprocess">
      <doc>
        Description of a data processing step.  
        One NXprocess for each data processing step.
        Record the date and time of the data processing step in the "date" field of NXprocess.
        Other fields include "program" and "version" fields and an NXnote for anything else.
      </doc>
    </group>
    
    <group type="NXcollection">
      <doc>
        Any set of fields or NeXus base clases.
      </doc>
    </group>
    
  </group>

</definition>
